#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;
/* Немного о функциях:
При вызыве какой-то функции, скажем system("chcp 1251"), основная ф.main встает на паузу, компилятор переходит в ОЗУ туда где лежит функция system, выполняет все ее со-
держимое и возвращается обратно (функция либо возвращает значение либо нет, а system возвращает). Возвращение вставится на место вызова функции, а потом работа ф.main
продолжится. Внутри функции можно вызывать еще функцию, и еще (лесенка функций). Создать функцию внутри функции нельзя, а вызывать можно сколько угодно раз (в момент
вызова ф.srand вызывается еще ф.time, т.к. вызовы функций можно комбинировать).

Напишу функцию, которая поменяет значения 2-х переменных местами. Возвращать она будет void, т.к. она никакого одиночного конечного результата не имеет.

                                                                 Механизм смены переменных местами:
1. Процессор все делает последовательно (операция за операцией). Решу проблему с помощью "буфера" - вспомогательной/временной п.temp с ограниченным сроком жизни (соз-
дастся на момент обмена, а далее она уже не нужна). Беру значение п.А и кладу его в п.temp, потом значение п.В кладу в п.А, а потом кладу в п.В значение из п.temp.
Главное чтобы тип данных п.А совпадал с типом данных п.В, и с типом данных п.temp.
("буфер" - распространенное действие не только для обмена местами, но и для передачи данных из одного места в другое чтобы где-то сохранить копию и т.д.)

2. Математически высчитать чтобы результаты вычислений поменялись местами, но это грамоздско и не всегда будет корректно.

(!) переменные внутри созданных функций создаются до запуска ф.main, т.к. функции это глоб.объекты, и как и глоб.п./к. они создаются в ОЗУ до вызова ф.main. При запуске
программы сперва выделяется память под глоб.ф., глоб.п./к., а потом уже под все переменные и объекты внутри ф.main. Т.о. под ф.Swap будет выделена отдельно память, а
значения п.one и п.two получат при вызове ф.Swap.

При вызове ф.Swap для работы внутри функции создаются п.one и two, становясь копиями п.A и B. Ф.Swap ничего про п.А и В не знает, т.к. получила лишь их значения. */
void Swap(int one, int two)
{
    cout << "Работает функция Swap!" << endl;
    cout << "Первое число: " << one << " Второе число: " << two << endl;
    int temp = one;
    one = two;
    two = temp;
    cout << "Первое число: " << one << " Второе число: " << two << endl;
    cout << "Функция Swap закончила работу!" << endl;
}

int CountEvenElements(int Array[], int size)
{
    int count = 0;                                                              // подсчет количества четных элементов массива
    //size = 15;
    for (int i = 0; i < size; i++)
    {
        if (Array[i] % 2 == 0)
        {
            count++;
            cout << Array[i] << " ";
        }
    }
    cout << endl;
    return count;                                                               // возвращаем количество четных элементов
}

int NegativeElements(int Massive[], int count);

int main()
{
    system("chcp 1251");
    system("cls");
    srand(time(NULL));

    int A = -3, B = 15;
    cout << "Число А: " << A << " Число В: " << B << endl;
    Swap(A, B);                                                                 // передача значений п.А и В в п.one и two
    cout << "Число А: " << A << " Число В: " << B << endl;
    /* При выводе п.А и В на экран после работы ф.Swap видно, что функция их местами не поменяла, т.к. функция имеет одну особенность: люб. функция работает не с пере-
    менными, а с их значениями. Сами переменные остаются без изменений.

    С массивами же немного иначе.
    Напишу функцию, вычисляющую количество четных элементов массива. Функция будет возвращать количество четных элементов. Массив характеризуется типом данных элементов,
    которые в нем хранятся и их количеством. Поэтому передавая массив в функцию необходимо отдельно передать его имя, указав тип данных и количество его элементов, ко-
    торые в массиве хранятся. Иначе при работе с массивом можно выйти за границы массива.
    После создания функции CountEvenElements необходимо создать сам массив, заполнить его элементами и вывести на экран. */

    system("pause");
    system("cls");
    const int size = 50;
    int Array[size]{};
    int result = 0;                                                             // результат работы функции
    for (int i = 0; i < size; i++)
    {
        Array[i] = rand() % (100 - (-99)) - 99;
        if (i % 10 == 0 && i != 0)cout << endl;
        if (Array[i] >= 0)cout << " ";
        if (Array[i] > -10 && Array[i] < 10)cout << " ";
        cout << Array[i] << " | ";
    }
    cout << "\n" << endl;
    /* Найду в массиве количество четных элементов. Вызову ф.CountEvenElements и верну ее в п.result. Передам туда имя массива и количество элементов в нем (в этот мо-
    мент студия сама подсказывает какие аргументы должны быть у функции) */

    result = CountEvenElements(Array, size);
    cout << "Количество четных элементов равно: " << result << endl;

    /* Работать с массивами внутри функций очень удобно. Вызову функцию и отправлю туда массив. Т.к. у функции при вызове указывается имя массива и количество его эле-
    ментов, можно одну и туже функцию использовать для разных массивов (не важно сколько в массивах будет элементов, функция будет работать, т.к. я передаю количество
    элементов). Правда функция сможет работать только с массивом типа int, но и это можно поправить.

    (!) каждый новый вызов функции это новая функция с новыми параметрами. Описание (действие) у нее одно и тоже, а значения, которые ей передаются разные. Функция это
    универсальный механизм, который получает значения при вызове и уже на основании именно этих значений выполняет все свои действия.

    (!) чтобы 100% быть уверенным что размер элементов в самой функции не изменится, можно добавить к размеру константу CountEvenElements(int Array[], const int Size);
    В таком случае константа примит размер массива чтобы он случайно не изменился.

    (!) когда функция получает массив в свои параметры нового массива не создается (как в случае с переменными). Она работает с тем самым массивом, который ей передан.
    Поэтому если внутри функции изменить элементы массива, изменится сам массив, который передался в качестве параметров. Имя массива, передаваемое в параметрах, назы-
    вается псевдоним массива, с ним идет работа внутри функций. Т.о. функция работает с массивом в той памяти, в которой он лежит.

    А теперь изменю массив в функции. Напишу прототип функции замены отрицательных элементов массива. Функция тоже будет считать количество отриц.элементов и возвращать
    его в качестве результата. Далее под ф.main напишу реализацию.
    (!) в прототипе можно не писать имена аргументов, а типы данных обязательно должны быть int NegativeElements(int[], int); т.к. память выделяется независимо от наз-
    вания аргумента, она выделяется под нужный размер, а размер берется по типу данных.

    Создадим прототип и саму ф.NegativeElements  */

    result = NegativeElements(Array, size);
    cout << "Количество отрицательных элементов равно: " << result << endl;
    // выведем массив на экран
    for (int i = 0; i < size; i++)
    {
        if (i % 10 == 0 && i != 0)cout << endl;
        if (Array[i] >= 0)cout << " ";
        if (Array[i] > -10 && Array[i] < 10)cout << " ";
        cout << Array[i] << " | ";
    }
    /* Было бы хуже если функция создавала бы копию массива, т.к. массивы занимают много памяти и при их дибликации место в памяти бы удваивалось. Заменим четные значе-
    ния массива на 0, нечетные на их положительную форму в ф.NegativeElements. Более того, я могу написать функцию, которая будет заполнять элементы любого массива и
    размера ГСЧ. Т.е. функция сможет заполнять абсолютно люб. массив, главное лишь передать его в параметрах. */
}

int NegativeElements(int Massive[], int count)                              // Massive здесь выступает как второе имя "псевдоним"
{
    int count_negative = 0;                                                 // будем считать количество отрицательных элементов
    for (int i = 0; i < count; i++)
    {
        if (Massive[i] < 0)                                                 // для отрицательных элементов массива
        {
            count_negative++;
            // если элемент четный, то заменим на 0
            if (Massive[i] % 2 == 0)Massive[i] = 0;
            else Massive[i] = -Massive[i];                                  // иначе изменим знак
        }
    }
    return count_negative;                                                  // возвращаем количество отрицательных элементов
}