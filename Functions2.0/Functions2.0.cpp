#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;
/* Немного о функциях:
При вызыве какой-то функции напр. system("chcp 1251"), основная ф.main встает на паузу, компилятор переходит в ОЗУ где лежит ф.system, выполняет все ее содержимое и
возвращается обратно (функция либо возвращает значение либо нет, а system возвращает). Возвращение вставится на место вызова функции, а потом работа ф.main продолжится.
Внутри функции можно вызывать еще функцию, и еще (лесенка функций). Создать функцию внутри функции нельзя, а вызывать можно сколько угодно раз (в момент вызова ф.srand
вызывается еще ф.time, т.к. вызовы функций можно комбинировать).

Напишу функцию, которая поменяет значения 2-х переменных местами. Возвращать она будет void, т.к. она никакого одиночного конечного результата не имеет.

                                                                 Механизм смены переменных местами:
1. Процессор все делает последовательно (операция за операцией). Решу проблему с помощью "буфера" - вспомогательной п.temp с ограниченным сроком жизни. Беру значение
п.А и кладу его в п.temp, потом значение п.В кладу в п.А, а потом кладу в п.В значение из п.temp. Главное чтобы тип данных всех переменных совпадал.
(Буфер - распространенное действие не только для обмена местами, но и для передачи данных из одного места в другое чтобы где-то сохранить копию и т.д.)
2. Математически высчитать чтобы результаты вычислений поменялись местами, но это грамоздско и не всегда будет корректно.

(!) переменные созданные внутри функций создаются до запуска ф.main, т.к. функции это глоб.объекты создаюющиеся в ОЗУ до вызова ф.main как и глоб.п./к.
При запуске программы сперва выделяется память под глоб.ф., глоб.п./к., а потом уже под все переменные и объекты внутри ф.main. Т.о. под ф.Swap будет выделена отдельно
память, а значения п.one и п.two получат при вызове ф.Swap.

При вызове ф.Swap для работы внутри функции создаются п.one и two, становясь копиями п.A и B. Ф.Swap ничего про п.А и В не знает, т.к. получает лишь их значения. */

void Swap(int one, int two)
{
    cout << "Первое число: " << one << " Второе число: " << two << endl;
    int temp = one;
    one = two;
    two = temp;
    cout << "Первое число: " << one << " Второе число: " << two << endl;
}
/* С массивами же немного иначе.
Массив характеризуется типом данных своих элементов и их количеством. След, передавая массив в функцию, необходимо отдельно передать ИМЯ массива, ТИП ДАННЫХ и КОЛИЧЕСТ-
ВО ЭЛЕМЕНТОВ массива. Иначе при работе с массивом можно выйти за границы массива.
Вызову функцию и отправлю туда массив. Одну и туже функцию можно использовать для разных массивов (не важно сколько в массивах будет элементов, функция будет работать с
переданным количеством). Каждый след.вызов функции это новая функция с новыми параметрами. Описание/действие у нее одно и тоже, а значения передаются разные. Функция э-
то универсальный механизм, который получает значения при вызове и уже на основании именно этих значений выполняет все свои действия. */

int CountEvenElements(int Array[], int size)
{
    int count = 0;                                                              // подсчет количества четных элементов массива
    //size = 15;
    for (int i = 0; i < size; i++)
    {
        if (Array[i] % 2 == 0)
        {
            count++;
            cout << Array[i] << " ";
        }
    }
    cout << endl;
    return count;                                                               // возвращаем количество четных элементов
}
int NegativeElements(int Massive[], int count);

int main()
{
    system("chcp 1251");
    system("cls");
    srand(time(NULL));

    int A = -3, B = 15;
    cout << "Число А: " << A << " Число В: " << B << endl;
    Swap(A, B);
    cout << "Число А: " << A << " Число В: " << B << endl;                      // люб. функция работает не с переменными, а с их значениями. Сами переменные остаются
                                                                                // без изменений
    system("pause");
    system("cls");
    /* После создания функции CountEvenElements необходимо создать сам массив, заполнить его элементами и ВЫВЕСТИ его НА ЭКРАН. */
    const int size = 50;
    int Array[size]{};
    int result = 0;                                                             // результат работы функции
    for (int i = 0; i < size; i++)
    {
        Array[i] = rand() % (100 - (-99)) - 99;
        if (i % 10 == 0 && i != 0)
            cout << endl;
        if (Array[i] >= 0)
            cout << " ";
        if (Array[i] > -10 && Array[i] < 10)
            cout << " ";
        cout << Array[i] << " | ";
    }
    cout << "\n" << endl;
    system("pause"); cout << endl;
    /* Найду в массиве КОЛИЧЕСТВО ЧЕТНЫХ ЭЛЕМЕНТОВ. Вызову ф.CountEvenElements и верну ее в п.result. Передам в функцию имя массива и количество элементов в нем (в этот
    момент студия сама подсказывает какие аргументы должны быть у функции) */
    result = CountEvenElements(Array, size);
    cout << "Количество четных элементов равно: " << result << endl;

    /* Функция работает с массивом в той памяти, в которой он лежит. Когда функция получает массив в свои параметры, нового массива не создается (как с переменными). О-
    на работает с тем массивом, который ей передан. След, если в функции изменить элементы массива, изменится сам массив, который передался в качестве параметров. Имя
    массива внутри функции называется псевдоним массива, с ним идет работа только внутри функций.

    Изменю массив в след.функции, заменю отрицательные элементы массива и сосчитаю количество отриц.элементов. Верну количество отриц.элементов в качестве результата.
    (!) в прототипе можно не писать имена аргументов, но типы данных обязательно должны быть int NegativeElements(int[], int); т.к. память выделяется независимо от наз-
    вания аргумента, она выделяется под нужный размер, а размер берется по типу данных. */

    result = NegativeElements(Array, size);
    cout << "Количество отрицательных элементов равно: " << result << endl << endl;
    system("pause"); cout << endl;

    // выведем массив на экран
    for (int i = 0; i < size; i++)
    {
        if (i % 10 == 0 && i != 0)cout << endl;
        if (Array[i] >= 0)cout << " ";
        if (Array[i] > -10 && Array[i] < 10)cout << " ";
        cout << Array[i] << " | ";
    }
    /* Было бы хуже если функция бы создавала копию массива, т.к. массивы занимают много памяти и при их дублировании место в памяти бы удваивалось. Заменю четные зна-
    чения массива на 0, нечетные на их положительную форму в ф.NegativeElements. Более того, я могу написать функцию, которая будет заполнять элементы любого массива и
    размера ГСЧ. Т.е. функция сможет заполнять абсолютно люб. массив, главное лишь передать его в параметрах. */
    cout << endl;
}
int NegativeElements(int Massive[], int count)                              // Massive[] тут псевдоним Array[]
{
    int count_negative = 0;
    for (int i = 0; i < count; i++)
    {
        if (Massive[i] < 0)
        {
            count_negative++;
            if (Massive[i] % 2 == 0) Massive[i] = 0;                        // если элемент четный, то заменим на 0
            else Massive[i] = -Massive[i];                                  // сделаем положительным
        }
    }
    return count_negative;                                                  // возвращаем количество отрицательных элементов
}
// (!) чтобы 100% быть уверенным что размер элементов в самой функции не изменится, можно добавить к размеру константу Имя(int Array[], const int size);