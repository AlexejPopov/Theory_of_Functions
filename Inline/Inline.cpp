#include <iostream>
#include <cstdlib>                                                          // т.к. нужна будет одновременно math.h и stdlib.h, которые объединены в cstdlib

#define HELLO "Привет, Мир!"
#define PI 3.14159
#define SQR(X) ((X)*(X))
#define CUBE(y) (SQR(y)*(y))                                                // имя параметра не имеет значения, оно работает только в самом макросе
#define ABS(A) (((A)<0)?-(A):(A))                                           // каждое А в скобках, чтобы сработало для каждого выражения
#define MULT(a,b) ((a)*(b))
using namespace std;

/* Переходы по памяти при стопоре функции main и выполнению другой функции бывают порой ресурсо-затратными. Рассмотрим на примере функции вычисляющую сумму квадратов.
При вызове функции в стандартном виде cout << SumSQR(A, B) << endl; в отладчике мы видим следующее: в момент вызова функции я перейду в памяти в реализацию функцию, вы-
полню там все и вернусь в место вызова. Чем больше таких вызовов, тем больше будет таких метаний из main в функцию и наоборот. Это временные затраты на обращение к па-
мяти где лежит функция. Если памяти мало, мощьности процессора слабые, если устройство маленькое (микроконтроллер и т.д.), то это очень критично.
В С++ возможно упростить это просьбой к компилятору попытаться встроить функцию, т.е. мы можем сказать, попробуй встроить мою функцию. Встраиваемая функция это такая
функция, при вызове которой произойдет следующее: компилятор, при переводе кода в машинный язык, увидит вызов встраиваемой функции и вместо этого вызова подставит со-
держимое моей функции, т.е. подменит вызов тем что указано внутри функции:
1. Перед типом возвращающего значения написать inline (это слово попытается попросить компилятор встроить функцию). Не каждая функция может быть встроена. Если функция
обладает большим размером ( > 20-ти строчек самостоятельных команд), то она скорее всего не встроится, рекурсивная функция не встроится, а также если функция содержит
циклы, switch или другие сложные конструкции, то встроить такую функцию не получится. Т.е. встроить можно только простую функцию.
2. Что будет пытаться сделать компилятор, чтобы встроить функцию? Когда мы создали ключ.слово inline перед именем функции, компилятор, при переводе кода в машинный язык
вот эту фразу cout << "Сумма квадратов двух чисел: " << SumSQR(A, B) << endl; превратит в cout << "Сумма квадратов двух чисел: " << A * A + B * B << endl; (т.е. он со-
держимое функции подставит сюда вместо вызова) и она в конечном итоге встроится вот так cout << "Сумма квадратов двух чисел: " << 3 * 3 + 4 * 4 << endl; но мы это не
увидим, компилятор сделает это за нас. Поэтому серьезные функции не смогут вот так встроиться.
Т.о. inline помогает компилятору не ходить каждый раз в память где лежит функция и не возвращаться потом обратно, а поместить содержимое функции прямо в вызов. Т.е.
когда я вызову функцию компилятор ее сразу превратит в такой вид A * A + B * B и тем самым ускорит работу моей программы т.к. не нужно будет прерывать main, идти в па-
мять выполнять функцию, возвращаться обратно. Этого всего не будет, функция просто сразу раскроется вот в эту конструкцию A * A + B * B.
(!) inline это всего лишь просьба. Если функция будет где-то чуть более сложная и у компилятора выполнить встраивание не получится, то я об этом никогда не узнаю, оши-
бок это тоже не вызовет. Если я написал inline и функцию не удолось встроить, то ничего страшного, она как была глобальной функцией, так и останется, но писать inline
перед всеми функциями нет никакого смысла и наоборот может быть больше ненужных действий. Писать inline нужно тогда, когда функция маленькая и простенькая. inline это
лишь просьба для очень простых функций я могу вместо их вызова поместить их содержимое чтобы не блуждать по памяти и не искать где оно там лежит, избегать задержек.

Помимо встраивания есть еще операция подстановки #define (директива препроцессора). Встраиванием занимается компилятор при переводе кода в машинный язык, а до компиля-
тора запускается специальная маленькая подпрограмма, которая называется препроцессор (предподготовка кода). Его задача выполнять собственные директивы (#). Директивы
препроцессора начинаются с '#'. Например так подключаются библиотеки (все что написано в библиотеке будет вставлено на место директивы). Задача препроцессора подгото-
вить текст наей программы к такому виду, чтобы компилятор мог с ним работать - выполнить предварительную подготовку текста. Препроцессор не выплняет никаких вычислений,
он не ищет никакой результат, у него нет функций и прочих механизмов призванных найти какое-то значение, он не создает никаки объектов, не выделяет никакой памяти. Мак-
симум что он делает - определенным образом формирует текст моей программы перед тем как к ниму приступит компилятор. Среди его компонентов, его директив есть директива
#define (директива подстановки). Она подставляет одни символы в замен другим символам (замена одних символов в тексте программы на другие символы перед компиляцией).
С помощью нее можно создать механику очень схожую со встраиванием.
Директивы препроцессора можно писать в любом месте программы. Где нужно там и пишу, но в большинстве слуаев они пишутся до main, перед всеми командами их выполняем, а
дальше уже выполняется основное содержимое моей программы. Создается:
#define (потом указываем через пробел имя) ИМЯ (и через пробел подставляемое содержимое вместо этого имени. И то что укажется после имени, именно это будет искать преп-
роцессор и его директива define в тексте моей программы, и вместо них будет подставлять что мы укажем в подставленном содержимом) ПОДСТАВЛЯЕМОЕ СОДЕРЖИМОЕ (в имени при-
думываются любые символы)
(!) директива препроцессора выполняется не компилятором, а препроцессором (предварительным обработчиком текста моей программы), и она выполнится в любом случае. Если в
inline я прошу вместо вызова функции подставить содержимое функции, то define это жесткая команда, которая выполнится в люб.случае. Есть три момента, в которых define
дает преимущество:

    1. Когда нужно заменить один текст на другой. Особенно удобно когда надо копировать и вставлять, например длинные команды. Удобно вместо них вводить что-то простое.
    2. Именование литералов. Простая подстановка вместо одних символов другие символы.
    3. Использование макросов (тоже подстановка)

1-й случай, можно использовать не только для вывода на экран, но и хранения, в том числе в строковых массивах фразу "Привет, Мир!".
Перед тем как компилятор будет переводить программу в машинный код, запустится препроцессор, он увидитсвою директиву define и везде ниже после того как она объявлена
будет искать свое HELLO и вместо нее подставлять свое подставное значение. Везде где я напише HELLO будет эта подстановка. Программу это замедлять не будет, т.к. inline
выполняет компилятор при переводе текста, а препроцессор вполнит свою работу еще ДО запуска компилятора (еще задолго до запуска самой моей программы). Запускаться прог-
рамма первый раз будет дольше, когда будет собираться в .exe файл, а на скорости работы самой программы это уже никак не скажется, а лишь на том как долго будет предва-
рительная подготовка, поэтому злоупотреблять define не стоит, но порой они очень полезны, в первую очередь для замены каких-то неудобных или больших символьных конст-
рукций. Главное чтобы это было целессообразно.

2-й случай - именование литералов (постоянных константных значений, указанных в тексте моей программы: 4 - целочисленный литерал типа int, "chcp 1251" это строковый ли-
рал). Я только что строковому литералу "Привет, Мир!" дал имя HELLO. Тоже самое можно делать и с числовыми литералами, например, если мне хочется создать глобальную
константу PI. И везде где мне нужно PI я буду подставлять глобальную константу. Тонкость в том, что под такую константу выделится память 8 байт. Она будет храниться от-
дельно, иметь значение 3.14 и каждый раз я буду к ней обращаться, она будет лежать где-то в памяти, и если я где-то в main напишу cout<<PI, компилятор пойдет в памяти
туда где создана глоб.константа, возьмет ее значение и выведет на экран в месте запроса. Получается таже история как и с функцией с лишними действиями, да и 8 байт не-
обходимо выделить. define тут может помочь. С его помощью можно дать имя литералу (в данном случае вещественному). Логика создания тела define таже. Применение define
ускоряет работу программы в скавнение с использованием глоб.константы, но тут надо соблюдать баланс между скоростью и читабельностью кода. define это замена одних сим-
волов на другие в тексте программы. А дальше компилятор с этим содержимым будет работать. define ничего не вычисляет, в памяти нигде не хранится. Тонкость лишь в том,
что компилятору перед началом работы нужно сначала пройти и подставить одни символы вместо других. В этом есть и плюс, но и одна осторожность. Если где-то в тексте
препроцессор видит где-то отдельные буквы PI отделенные пробелом, то он везде будет подставлять заменяемое значение, и ему не важно где это написано. Если я создам пе-
ременную float PI = 3.14, то у меня будет float 3.14 = 3.14. А также ничего нельзя этому PI присвоить (изменить значение), т.к. при обработке PI станет просто цифрами
float 3.14 = 3.14 т.к. это литерал вещественный, которому дали "позывное имя" PI.
(!) препроцессор может подставлять все что угодно и даже огромное количество текста.
(!) если строки не хватио и нужно перенести, то есть '/'. Но только не внутри текста, а внутри команды. '/' разделяет содержимое одного define на 2 строки.

3-й случай - макрос. Это такая же подстановка, но чуть сложнее, и идет она еще и в обратную сторону.
#define ИМЯ(параметры) (выражение, в которое будут подставлены параметры)
Имя и параметры пишутся слитно, потом через пробел указываются выражения, в которые будут подставлены параметры. Вот это выражение, в которое будут подставлены парамет-
ры в конечном итоге вернется на место имени макроса.
У нас есть A * A + B * B, но так писать несолидно, особенно когда много скобок и мат.действий. У нас есть функции, но если нужно сделать всего одно действие, например
возвести число в степень, функция pow неэкономичное решение, к ней нужно подключать огромную библиотеку math.h, в которой на эту функцию отведено лишь несколько строк,
а все остальное будет баластом кода (особенно критично для слабопроизводительных устройств). Решением будет макрос, он заменяет одну текстовую(символьную) конструкцию
на другую чуть более сложную. Заменю return макросом return SQR(a) + SQR(b); Понимается это так: значение SQR(a) подставится в SQR(X), а потом выполнится по инструкции
макроса (X*X), а потом результат вернется в SQR(a). Макрос это не функция, это команды (замена одних символов на другие). А препроцессор видит это иначе: когда препро-
цессор обработает #define SQR(X) (X*X), он пойдет искать SQR, найдет SQR(a), подставит а в макрос (X*X), и получившийся результат вернет вместо SQR(a).
(!) SQR(A+B) (A+B*A+B), это неверное действие, след, необходимо каждый объект/параметр оборачивать в скобки ((X)*(X)) => ((A+B)*(A+B)). Такая операция позволяет рабо-
тать с выражениями, а не только с отдельными объектами.
(!) когда надо экономить на памяти и делать программу быстрой, то нужно создавать свои функции (библиотеки) с лишь необходимым вместо стандартных с внушительным баллас-
том. В свою библиотеку я могу собрать несколько нужных функций, а стандартная библиотеки могут включать аж тысячи разных функций. Если программа для микроконтроллера,
то там каждый бит на счету, а если для ПК, то можно себе позволить пожертвовать скоростью ради удобства написания/поддержки программы.
В памяти макрос не хранится. Его обрабатывает препроцессор, раскрывает его в набор скобок, передает их дальше компиллятору и компиллятор дальше создает машинный код. */

const double Pi = 3.14;

inline float SumSQR(float a, float b)
{
    //return powf(a, 2) + powf(b, 2);                                       // не встроится т.к. это сумма двую функций со встроенными внутри циклами
    //return a * a + b * b;                                                 // вероятность быть встроенной теперь выше (но это неэтичный вид записи)
    return SQR(a) + SQR(b);
}

int main()
{
    system("chcp 1251");
    system("cls");
    int A = 3, B = 4;
    cout << "Сумма квадратов двух чисел: " << SumSQR(A, B) << endl;
    cout << "Сумма квадратов двух чисел: " << A * A + B * B << endl;
    cout << "Сумма квадратов двух чисел: " << SumSQR(3, 4) << endl;         // компилятор выполнит теже действия что и с вызовом выше (это не встраивание)
    cout << "Привет, Мир!" << endl;

    cout << HELLO << endl;
    cout << HELLO << endl;
    cout << HELLO << endl;
    cout << HELLO << endl;
    cout << HELLO << endl;
    cout << HELLO << endl;

    //(A+B)^2
    cout << pow(A + B, 2) << endl;                                          // не рационально
    cout << (A + B) * (A + B) << endl;                                      // примитивно, но сработает явно быстрее без посещения памяти и лишних библиотек
    cout << SQR(A + B) << endl;                                             // правильно!

    //((A+B)^2*(A-B)^2)^2
    cout << pow(pow(A + B, 2) * pow(A - B, 2), 2) << endl;                  // 3 раза компилятор пойдет в функцию pow
    cout << ((((A + B) * (A + B)) * ((A - B) * (A - B))) * (((A + B) * (A + B)) * ((A - B) * (A - B)))) << endl;
    cout << SQR(SQR(A + B) * SQR(A - B)) << endl;                           // вот это совсем другое дело! Но сам макрос раскроется как строка выше без нашего участия

    /* Возведение в куб
    #define CUBE(y) (SQR(y)*(y)) или ((y)*(y)*(y)) Внешние скобки тут нужны чтобы при обратной подстановке, когда будет готовое выражение возвращаться, чтобы его можно
    было использовать в составе любого другого готового выражения. (SQR(y)*(y)) == ((y)*(y)*(y)). В макросе можно использовать макросы, ранее написанные.
    |3|==3; |-3|==3; без учета знака.
    В коде мы так можем пока написать так: if(A<0)-A; else A;
    И с помощью тернарного оператора, он возвращает результат: (A<0)?-A:A; (результат можно в какую-то переменную поместить и тернарный оператор можно сделать макросом)
    Терн.оператор: (условие)? выражение если условие истина : выражение если условие ложь; (в макросе ';' не ставится)
    Написанный макрос #define ABS(A) (((A)<0)?-(A):(A)) возьмет модуль от любого выражения!

    Напишем |(A-(A+B)^2)^3| в трех вариантах: макросом, функцией или вручную */
    cout << ABS(CUBE(A - SQR(A + B))) << endl;
    cout << (((pow((A - pow(A + B, 2)), 3)) < 0) ? -(pow((A - pow(A + B, 2)), 3)) : (pow((A - pow(A + B, 2)), 3))) << endl;    // решение функцией
    cout << abs(pow((A - pow(A + B, 2)), 3)) << endl;                                                                           // с функцией взятия по модулю
    cout << ((((A - ((A + B) * (A + B))) * (A - ((A + B) * (A + B))) * (A - ((A + B) * (A + B)))) < 0) ? -((A - ((A + B) * (A + B))) * (A - ((A + B) * (A + B))) * (A - ((A + B) * (A + B))))
        : ((A - ((A + B) * (A + B))) * (A - ((A + B) * (A + B))) * (A - ((A + B) * (A + B))))) << endl;
    /* Макросы нужны чтобы не запутаться в огромном количестве символов, которые достаточно сложны в написании, а не все подряд заменять.
    В примере выше макрос ABS раскроется в огромную пачку скобок, написанную вручную выше, но нам это там делать будет не нужно, это сделает препроцессор. И это будет
    быстрее и оптимальнее чем использовать функции.

    Параметров в макросе может быть не один, а больше. Есть даже стандартные макросы, в некоторых библиотеках используются. Напишу макрос перемножения MULT. Такой мак-
    рос можно использовать, передавая в него два отдельных параметра. А также макрос можно применять для двух выражений. */
    cout << MULT(SQR(A + B), ABS(CUBE(A - SQR(A + B)))) << endl;
}