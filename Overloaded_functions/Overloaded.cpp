#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;

/* Перегрузка функций:
Часто при написании функций приходится писать функции, которые работаею схожим образом и отличаются немногим. Например, одна и таже функция для массива целого и вещест-
венного. Одинаковые массивы, одинаковые технически функции, но их будет две, т.к. типы данных массивов разные. А также для каждой функции придется еще придумывать новое
имя. Перегрузка функций позволяет создать несколько функций, обладающих одним и тем же именем. Чтобы не придумавать новые имена новым функциям используется перегрузка
функции. Она позволяет под одним именем написать несколько функций, которые будут себя вести подобным образом, и позволяет вызывать с помощью одного имени различные
функции по количеству параметров, типу данных параметров и различные по реализации внутри.
Перегрузка используется тогда, когда есть несколько функций схожих по своему функционалу (по своему содержимому и поведению), которые можно объединить одним именем,
например pow, powf, powl, и, в зависимости от того как вызывается функция по этому имени, будет вызываться нужная ее реализация. Внутри main или где нужно вызвать функ-
цию будет писаться ее имя, передаваться в нее параметры, а программа сама будет определять какую именно из версий функции необходимо вызвать.

                            Перегрузка бывает 4-х видов:
1. перегрузка по типу данных аргументов (когда функции отличаются лишь типами данных)
2. перегрузка по количеству аргументов функции (когда в функциях разное количество аргументов)
3. перегрузка по порядку аргументов функции (когда в функциях разный порядок аргументов)
4. перегрузка по всему вместе
(!) тип возвращаемого значения функции не влияет на перегрузку функции. Функция, отличающаяся только типом возвращающего значения не будет перегружена (должны отличать-
ся именно параметры. Имя функции должно быть одинаковое, параметры, указанные в кругл.скобках должны быть разные, а тип возвращаемого значения может быть одинаковым, а
может и нет, он не учитывается.
(!) имена аргументов в параметрах функции никак не влияют на перегрузку. Имена могут быть любые. Недостаточно изменить только имя параметра чтобы выполнить перегрузку,
нужно менять либо типы данных либо их количество, либо их порядок. Компилятор видит это как double Multi(double, double)
(!) если изменить только тип данных возвращаемого значения, то это тоже не будет основанием для перегрузки, т.к. компилятор не сможет перегрузить функцию, различаемую
только по типу возвращаемого значения.
(!) перегружать можно и более детально в конкретных типах данный, изменяя порядок типов данных в параметрах. А жестче будет изменив типы данных, количество и их порядок

I. Перегрузка функции по типу данных аргументов
   Ниже будут массивы int, double и char */

int Find_Max_Element(int Array[], int size)                                 // функция для массива типа int
{
    int max_element = Array[0];
    for (int i = 1; i < size; i++)
    {
        max_element = Array[i] > max_element ? Array[i] : max_element;      // если условие истина, то Array[i] поместиться в max_element, если ложь, то max_element по-
    }                                                                       //местится в max_element
    cout << "Для массива типа int: ";
    return max_element;
}
double Find_Max_Element(double Array[], int size)                           // функция для массива типа double
{
    double max_element = Array[0];
    for (int i = 1; i < size; i++)
    {
        max_element = Array[i] > max_element ? Array[i] : max_element;
    }
    cout << "Для массива типа double: ";
    return max_element;
}
char Find_Max_Element(char Array[], int size)                               // функция для массива типа char  
{
    char max_element = Array[0];
    for (int i = 1; i < size; i++)
    {
        max_element = Array[i] > max_element ? Array[i] : max_element;
    }
    cout << "Для массива типа char: ";
    return max_element;
}

// II. Перегрузка функции по количеству аргументов функции

double Multy(double X = 3.5)
{
    return X * X;
}
double Multy(double X, double Y)
{
    return X * Y;
}
double Multy(double X, double Y, double Z)
{
    return X * Y * Z;
}
double Multy(double X, double Y, double Z, double W)
{
    return X * Y * Z * W;
}
/*
double Multy(double X, double Y, double Z, double W = 3.5)                    // 4 аргумента со значением по умолчанию
{
    return X * Y * Z * W;
}

III. Перегрузка функции по порядку элементов для массива типа данных double */

double Find_Max_Element(int size, double Array[])
{
    double max_element = Array[0];
    for (int i = 1; i < size; i++)
    {
        max_element = Array[i] > max_element ? Array[i] : max_element;
    }
    cout << "Для массива типа double: ";
    return max_element;
}

int main()
{
    system("chcp 1251");
    system("cls");
    srand(time(NULL));
    const int size = 10;
    int A[size]{};
    double B[size]{};
    char C[size]{};
    for (int i = 0; i < size; i++)
    {
        A[i] = rand() % 100;
        B[i] = (rand() % 100) * 1.1;
        C[i] = rand() % 256;
        cout << A[i] << "\t" << B[i] << "\t" << C[i] << endl;
    }
    /* cout << Find_Max_Element(A, size) << endl;
       cout << Find_Max_Element(B, size) << endl;                              // не получится, т.к. аргумент типа double несовместим с int
       Можно по аналогии функции pow написать другую функцию для другого типа данных:
       cout << Find_Max_Element_Int(A, size) << endl;
       cout << Find_Max_Element_Double(A, size) << endl;
       но это неудобно, особенно если много типов данных. С помощью перегрузки я напишу точно такую же функцию с тем же именем, но для типа данных double, чтобы можно было
       ее применить к массиву В. Т.к. функции не будут ничем отличаться кроме типов данных, я беру и копирую функцию, меняя везде int на double. Теперь это две функции с
       одним и тем же именем, но разным типом данных (там массив целых чисел, а тут дробных). В ОЗУ они лежат отдельно друг от друга, обращение к ним происходит по их мес-
       тоположению в памяти, поэтому и возможно использовать общие имена. Но чтобы не было путаницы параметри должны быть разные. Именно параметры определяют отличие одной
       функции от другой (ни возвращаемое значение, ни имя функции, а параметры). Смена типов данных параметров и есть перегрузка. */

    cout << Find_Max_Element(A, size) << endl;
    cout << Find_Max_Element(B, size) << endl;
    cout << Find_Max_Element(C, size) << endl;
    cout << Find_Max_Element(size, B) << endl;
    //cout << Find_Max_Element(size, А) << endl;                            // такой перегрузки нет
    system("pause");
    system("cls");
    /* Когда перегружена функция, как происходить ее вызов? Создам еще массив символом. При вызове функции, открыв скобки студия подскажет что есть две (перегрузки).
    Создав еще функцию для char, у меня появится третий вариант для char. В символах char тоже можно найти max элемент, сравниваются они по кодам из кодовой таблицы. В
    момент вызова, компилятор анализирует какой тип данных передан при вызове, и по этому типу данных определяет какой из трех вариантов функций надо вызвать. Поставив
    точку остановы, зайду в отладчик (F5). Нажимая F11 (Step Into), зайду в нужную функцию. Если нужного типа данных скажем float нет в перегрузке, а есть лишь double,
    то функция не вызовется. Позже можно будет разделять проект на файлы и убирать функции в отдельный файл, создавать свою библиотеку, свой заголовочный файл, и из нее
    уже вызывать нужную.
    (!) тело перегруженных функций может координально отличаться. Сейчас отличия лишь в типе данный и тексте для экрана, но они могут быть координально разные, но жела-
    тельно придерживаться какой-то логике. Если в заголовке написано поиск максимального элемента, то функции нужно писать для этого.

    Создано 4 варианта функции Multy. У каждой разное количество аргументов. Вызовем функцию для 4-х значений, 3-х, 2-х, 1-го. Каждый раз будет вызвана разная функция
    в зависимости от того количества параетров, которые в нее были переданы. Это хорошо видно в отладчике с заходом в функции F11 (какая функция вызывается). */

    cout << Multy(3.14, 2.5, 4.0, 3.7) << endl;
    cout << Multy(3.14, 2.5, 4.0) << endl;
    cout << Multy(3.14, 2.5) << endl;
    cout << Multy(3.14) << endl;
    cout << Multy() << endl;                                // вызов пустой функции без параметров, который примет значение по умолчанию

    /* Запись выше напоминает задание параметров функции по умолчанию, а именно функцию Symbols, в которую передавалось 3 параметра: символ, строки и столбцы. И указав
    их значения по умолчанию вызывалась функция с 3-мя параметрами, с 2-мя, с 1-м параметром или же вообще без параметров. Но есть один нуюнс, когда создавалась функция
    с значением параметров по умолчанию, это была одна функция, одна реализация, она одна лежала в памяти, но вызывалась по разному. А сейчас это 4 отдельные функции,
    отдельно лежащие в памяти с отдельным содержимым и выполняющие абсолютно разные действия. Они могут возвращать разные значения. В функцию с параметрами по умолчанию
    можно разное количество передавать, но нельзя изменить ни тип данных параметров (т.к. это одна функция, а в перегрузке можно поменять, перегрузить с другими типами
    данных), ни изменить тип данных возвращаемого значения (если написан int, то она и вернет int). В функции с параметрами по умолчанию можно редактировать ее содержи-
    мое с if else например, если передали 2 параметра, а не 3 выполнять какую-то другую реализацию, но это грамоздско и неудобно. А перегрузка позволет более гибко уп-
    равлять теми функциями, которые будут вызываться в ту ситуацию когда это будет нужно. Параметры по умолчанию это просто другой инструмент, который нужен для других
    целей.
    (!) перегрузку и значения параметров по умолчанию можно также использовать вместе, но если функция перегружается по количеству аргументов и используются параметры
    по умолчанию, то нужна аккуратность. Т.к. задача параметров по умолчанию начинается с последнего параметра. Дам W значение по умолчанию и функция не запустится :(.
    Произойдет неоднозначный вызов перегруженной функции. При вызове функции и передаче ей 3-х значений компилятор не может понять какую из двух функций необходимо выз-
    вать, ту, в которой только 3 хначения или ту, в которой 3 значения и еще есть параметр по умолчанию, не задающийся в параметры при вызове. Если вдруг задание пара-
    метра по умолчанию приведет к совпадению одной функции с другой перегруженной функцией, это будет проблема. Но значения по умолчанию в перегрузке использовать все-
    таки можно, но нужно делать правильно. У меня нет функции Multy без параметров, а с 1-м, с 2-мя - с 4-мя параметрами, а след, если сделать так double Multy(double
    X=3.5), то вызов такой функции будет возможен с 1-м аргументом и без аргументов, и при этом такая функция ни с чем не совпадет и все будет нормально работать. Бла-
    годаря значению по умолчанию появилась возможность вызова функции без аргумента (но не реализация функции без аргумента появилась, а возможность вызова).
    (!) если не вызывать функцию double Multy(double X, double Y, double Z, double W = 3.5) компилятор и не сообщит совпадение пока функция не будет вызвана. Пока она
    не вызвана все будет "зелененько" и работоспособно компилятор не сравнивает и показывает что ошибок нет, поэтому нужно тут быть очень внимательным.

    (!!!) Перегрузка нужна: очень часто реализация функций отличается незначительно, но в зависимости от того какие аргументы используются, реализацию придется менять. */
}