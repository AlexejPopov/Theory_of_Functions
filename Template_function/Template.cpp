#include <iostream>
#include <time.h>
#include <stdlib.h>
using namespace std;

/* Шаблоны функций - это "бланк функции", основная часть функции, которая заполняется нужным типом данных при ее вызове. Перепишу ф.Find_max_element при помощи шаблона.
Это не совсем готовая функция, шаблон в памяти, как отдельная функция, не хранится, т.е. он не вызывает генерацию кода компилятором. Компилятор создает код функции лишь
в момент ее вызова. Только когда шаблонная функция будет вызвана, она будет создана только для нужного типа данных. Если я буду вызывать функцию только для одного типа
данных, то в памяти появится реализация функции только для этого типа данных. Но, как только я вызову эту функцию для другого типа данных, будет сформирована еще одна
реализация функции, будет также размещена в памяти. Т.е. при вызове этой функции для каждого нового типа данных, для него будет формироваться новая версия функции и
располагаться в памяти. Если потом вызвать предыдущую версию функции, то она уже вызовется из памяти, а с новым типом данных будет заново создана. При том шаблон уни-
версален, он может работать с любым типом данных, главное чтобы содержимое этой функции корректно отрабатывало для этого типа данных (кроме нестандартных). А для моей
функции еще проще ибо поиск максимального элемента работает с любым типом данных, т.к. элементы любых типов данных можно сравнивать друг с другом.
(!) не нужно будет прописывать несколько реализаций, она пропишется 1 раз, но шаблонно.

Шаблон можно также объявлять с помощью прототипа функции, по абсолютно тойже логике.

Шаблон функции поиска максимального элемента для массива люб.типа данных. Сперва пишется ключ.слово template, далее в угловых скобках пишется ключ.слово typename, соз-
дающее переменный тип данных и вкладывающий его любой символ/цифру... (принято брать Т). А вместо Т потом будет подставлен нужный тип данных (будет подстановка в момент
вызова функции).
(!) вместо ключ.слова typename может быть использовано ключ.слова class. Но это ключ.слово используется для шаблонных классов, а для отдельных функций лучше typename,
но разницы между ними нет.
Теперь это значит что в моей функции где-то будет указано Т вместо типа данных. А если я определяю новое имя типа typenamwe типа Т, то эта Т обязана присутствовать в
качестве типа данных в параметрах функции. И именно оттуда и будет взят тип данных при вызове функции. Ф.Find_max_element должна возвращать значение максимального эле-
мента, принимать она будет массив и его размер. А сам массив будет иметь тип данных Т, и возвращать в качестве результата буду тип данных Т.
Это значит что в момент вызова функции (в main) у меня будет созданна реализация для определенного типа данных. Если я вызову для массива типа int, то у меня получится
как внизу. Тип данных будет взят из параметра, у которого написано Т (будет передан массив типа int и везде во всей функции вместо Т подставится int [найти-заменить], и
для этого найденного и подставленного в нужный момент типа int будет создана реализация функции в памяти. Сама функция будет вести себя как раньше.

					 int Find...        (int Array[], int size) */
template <typename T> T Find_Max_Element(T Array[], int size)
{
	T Max_Element = Array[0];													// переменная Max_Element будет иметь тот же тип данных что и элементы массива Array
	for (int i = 1; i < size; i++)												// внутри функции наличие Т не обязательно. Главное чтобы он был в параметрах, и
	{																			// возвращать его тоже не принципиально (зависит от функции). Если Т указан в typename,
		Max_Element = Array[i] > Max_Element ? Array[i] : Max_Element;			// то и в параметрах Т должно быть.
	}
	return Max_Element;
}
/* Когда вызывается функция для массива int, сперва передается int Array, этот int подметяет Т в возвращаемом значении, в типе данных переменной Max_Element и вообще
везде где нужна будет. А потом создается функция с типами данных int, и далее идет работа уже с реализацией данной функции с int. Буду вызывать для double, подставится
всюду double и будет создана нужная реализация.

Переопределять типы данных можно неоднократно. Здесь может быть ни один typename, а несколько typename, указанных через запятую. И каждый typename ДОЛЖЕН присутствовать
в параметрах, и Т, и L. Размер может быть типа данных L (long, long long, любой целочисленный):
template <typename T, typename L> T Find_Max_Element(T Array[], int L)

Разные буквы (typename) можно использовать только когда типы данных различаются (или одинаковы это тоже можно), но, на моем примере, если я поставлю и в size Т, то я
передам массив типа double, и size типа double, а это неправильно, такой вызов не сработает. Нужно передавать double Array и int size. Если так надо, то нужны РАЗНЫЕ
буквы (либо я в параметры размера вставляю обычный int). */

int main()
{
	system("chcp 1251");
	system("cls");
	srand(time(NULL));
	const int size = 10;
	int A[size]{};
	double B[size]{};
	char C[size]{};
	float D[size];
	for (int i = 0; i < size; i++)
	{
		A[i] = rand() % 100;
		B[i] = (rand() % 100) * 1.1;
		C[i] = rand() % 256;
		D[i] = (rand() % 100) * 1.1F;
		/* rand() генерирует только целое число типа int, а я его далее уже преобразую к нужному, домножим на литерал типа double/float, получу double/float и т.д. А
		символы, они имеют таблицу числовых кодов в кодовой странице АСКИ. У каждого символа есть свой числовой код в этой таблице, ГСЧ генерирует этот код, а при поме-
		щении в массив этот код переводится в символ.
		cdecl означает десятичное число (просто обычный int) */


		cout << A[i] << "\t" << B[i] << "\t" << C[i] << "\t" << D[i] << endl;
	}
	cout << "Максимальный элемент типа int: " << Find_Max_Element(A, size) << endl;
	/* Поднеся мышку к Find_Max_Element, я вижу что мой вызов шаблонной функции преобразуется вот к такому:
	int Find_Max_Element <int>(int*Array, int size)
	возвращаю int, принимаю int массив, а тип данных в угловых скобках означает что подставился int. Т.е. компилятор взял тип данных массива А, перешел в реализацию
	функции и везде вместо Т его там подставил и создал в памяти функцию для типа данных int.

	Достоинства: для другого типа данных, например double или char, достаточно просто вызвать массив нужного типа данных, и не надо писать еще одну реализацию функции.
	И т.о. получу 3 реализации функции, каждая для соего типа данных, но они будут созданы только в момент вызова. */

	cout << "Максимальный элемент типа double: " << Find_Max_Element(B, size) << endl;
	cout << "Максимальный элемент типа char: " << Find_Max_Element(C, size) << endl;

	/* (!) написав шаблонную функцию, я сразу на будущее сделал реализацию для всех стандартных типов данных, например, я добавлю новый массив float D. У меня сразу бу-
	дет готова реализация подходящая для типа данных flost. Теперь осталось лишь вызвать функцию и создать ее в памяти.
	Еще можно переопределить шаблон, если создать отдельную функцию с таким же именем, но с указанными явно типами данных (не шаблонную, без преписки template), то для
	нужного типа данных будет вызываться нужная функция. Т.е. можно сделать отдельную нешаблонную реализацию для какого-то определенного набора параметров.
	В шаблонах можно использовать значения параметров по умолчанию (будем проходить в шаблонах функции сортировки).

	Недостатки: реализация одна. Внутреннюю состовляющую функции, кроме типов данных, поменять нельзя. В перегрузке например можно сделать разные реализации для разных
	типов данных, как делалось в примере раньше. В этом тоже есть свои плюсы, можно для какого-то конкретного типа данных реализовать функцию каким-то другим способом.
	В перегрузке может отличаться содержимое функции, в шаблоне нет. */

	cout << "Максимальный элемент типа float: " << Find_Max_Element(D, size) << endl;
}
/* Итог: если несколько функций нужно объединить под одним именем, при этом они отличаются лишь типами данных, а содержимое одинаковое, то тут нужно применить шаблон.
Если несколько функций нужно объединить под одним именем, но у них может отличаться возвращаемое значение, тело функции например, или количество параметров или их поря-
док, то тут нужно применить перегрузку.
А если нужно вызывать функцию просто со значением какого-то параметра по умолчанию, то просто используется параметр по умолчанию. */