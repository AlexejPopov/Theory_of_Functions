#include <iostream>
#include <locale.h>
using namespace std;
/* Функция это конструкция языка программирования, с помощью которой фрагмент кода можно вынести за пределы ф.main и неоднократно использовать в любом месте моей прог-
раммы. Функции создается имя, и по этому имени идет связь с функцией. Функции создаются для фрагментов кода повторяющихся в программе в разных местах несколько раз, ко-
торые можно вынести за тело программы (за ф.main). Этот фрагмент кода получает собственное имя и далее может быть использован в нужном месте при указании его имени.

                                                                        Назначения функций
1. Чтобы не писать одно и тоже несколько раз.
2. Собрать в единый механизм/конструкцию часть программы, выполняющую какое-то действие. А именно, если надо какую-то сложную конструкцию обособить и вынести за тело
программы (функции позволяют разбить всю программу на блоки/модули/механизмы).

В функцию можно пометить все механизмы, изученные ранее (if else, switch, циклы, массивы, одиночные переменные, константы...)
У функции есть 2 основных компонента, заголовок и тело. Заголовок определяет сигнатуру функции. Сигнатура функции это определенный набор характеристик, определяющий
функцию и отличающий ее от других функций. Функции, как и массивы, поддерживаются самим языком программирования и никаких библиотек не требуют. Заголовок функции еще
называется объявление функции, а тело - реализация функции.

                                                                       Заголовок состоит из:
1. Имя функции (задается нами при объявлении функции)
2. Параметры (аргументы) функции - значения, которые нужно в функцию передать, чтобы она смогла на их основании выполнить какие-то действия. Это входные данные, необхо-
   димые функции для работы над кодом. В качестве параметров можно использовать много чего, но чаще всего переменные.
3. Возвращаемые значения - результат работы функции. Функция обязательно должна возвращать значение. Если у функции есть какой-то конечный результат работы, например,
функция вычисляет площадь прямоугольника, то результат ее будет площадь прямоугольника. Если результат у функции однозначный (одиночное, точное, осмысленное значение),
то при объявлении (описании) функции необходимо указать тип данных этого значения, напр. int main().
Если у функции нет одиночного однозначного значения или оно неизвестно, напр. функция лишь что-то выводит на экран консоли, то она при этом никаких вычислений, мат.опе-
раций и прочего не выполняет, след, и осознанного результата у нее тоже нет. Для нее должен быть указан тип возвращаемого значения void.

Все функции создаются вне функции main. Создавать новую функцию внутри main нельзя, но можно созданную снаружи функцию использовать внутри main.

                                                                Функции можно создавать двумя способами:

I. Объявление и реализация функции в одном месте (неразрывно заголовок и тело)
II. Объявление функции прототипом с реализацией после функции main

                                                                    Объявление и реализация функции
Сперва пишем возвращаемое значение - результат работы функции. Функция для "Привет, Мир!" конечное значение (вычисленное число) иметь не будет. Она лишь выведет текст
на экран. Ставим ключевое слово void, пишим имя функции и ставим (). В () вносим параметры, которые функция должна принять для своей работы. Т.к. моя функция выводит
лишь текст на экран, то ей никаких параметров и не надо (текст везде одинаковый, без изменений), () будут пустыми. Затем, ставим блоковые фиг.скобки, в которых находит-
ся тело функции. */

void Hello()                                                                                // не принимает никаких параметров и не возвращает результат
{
    cout << "Hello world!" << endl;
}
/* В тех местах, где нужно использовать содержимое этой функции (вывести текст на экран), нужно лишь обратиться к функции Hello (вызвать функцию). Чтобы вызвать функцию
нужно написать ее имя и передать ей параметры, необходимые для ее работы. Но т.к. моей функции Hello никаких параметров для работы не требуется, то вызовется она тоже
просто. Там, где нужно вызвать функцию, я лишь напишу ее имя и укажу пустые скобки (). Скобки () обязательны, даже если нет параметров, т.к. именно скобки () обозначают
вызов функции. ';' в конце обязательна, т.к. вызов функции это законченная мысль. Эта функция без параметров.

Также функции бывают принимающие параметры и возвращающие результат. Создам функцию, которая будет принимать 1 параметр, но не будет возвращать результат. Напр. функция
будет выводить на экран заданное количество звездочек. Функция примет количество звездочек в качестве параметра и выведет на экран заданное количество звездочек. Но т.к.
количество звездочек для вывода будет задано, функция не будет ничего вычислять, а след, и возвращать результат она не будет, введу void. А принимать она будет коли-
чество звездочек в качестве параметра, след, необходимо в круглых скобках указать параметр, его тип данных и имя. У количества звездочек будет int. Функция содержит
переменную, которую нужно задать для выполнения цикла, но в самой функции cin нет, след, нужно задать значение переменной при вызове функции. Это называется принять 1
параметр (одну переменную). Принятие осуществляется заданием переменной в круглых скобках при вызове функции. */

void Stars(int Count)                                                                       // функцмя принимает 1 параметр и не возвращает результат
{
    for (int i = 0; i < Count; i++)
    {
        cout << "*";
    }
    cout << endl;
}
/* Как работают функции?
В момент вызова функции основная ф.main встает на паузу. Она останавливается и управление переходит в функцию (в то место где функция инициализировалась/лежит в ОЗУ) и
функция начинает работу. До тех пор пока она работает, main стоит на паузе. Как только все действия, указанные в теле функции выполнятся, компилятор вернется в место
вызова функции и продолжит дальнейшие действия по коду программы. Это ярко видно в отладчике (Step Into/Шаг с заходом). Это отладка с заходом в функции, которые написа-
ны для моей программы. Передам значение '5' и распишу механику:
При вызове функции компилятор переходит к открывающейся фиг.скобке, происходит внутреннее действие. Те параметры, указанные в заголовке функции (int Count) создадутся и
получат значения, переданные при вызове '5'. В момент вызова ф.Stars будет создана переменная int Count, она получит значение '5' и будет использоваться в моей функции.
(!) все, что создается внутри функции, доступно только внутри функции и пока функция работает.
Как только функция закончила работу, переменная Count исчезнет и больше к ней доступа не будет. А след, имена параметров функции могут быть точно такими же как и назва-
ния других объектов кода. Они никак не будут связаны. Count в ф.main и Count в ф.Stars это абсолютно разные переменные, никак не связанные между собой. Count в Stars
живет только в ф.Stars, а Count из main живет только в main. Когда я вызову ф.Stars и напишу в ней Count из main, то значение переменной Count из main перейдет в Count
из Stars и ф.Stars будет с этим значением работать.

Т.о. передается не сама переменная в функцию, а лишь ее значение, след, в main передающая переменная может иметь любое имя, необязательно такое же как в функции Stars.
Также можно перед передачей значения в функцию, ввести это значение с клавиатуры. Пусть функция будет выводить на экран не заданный, а любой символ, след, она будет
принимать два параметра (количество символов и сам символ). Функция будет выводить на экран линию из символов и не будет ничего возвращать, ни площадь, ни рассчет з/п,
она просто будет выводить звездочки на экран. */

void print_line(char Symbol, int Count)                                                     // функция принимает два параметра, но не возвращает результат
{
    if (Count <= 0)
    {
        cout << "Количество символов должно быть больше нуля!" << endl;
    }
    for (int i = 0; i < Count; i++)
    {
        cout << Symbol;
    }
    cout << endl;
}

/* Сигнатура функции это void print_line(char Symbol, int Count). В нее входят возвращаемое значение, имя функции и параметры (их количество и типы данных).
П.Count в ф.print_line не имеет никакого отношения к п.Count ф.main или ф.Stars. Это три разные переменные с одним именем, обладающие разной областью видимости. Когда
используется функция с 2-я и более параметрами, нужно при вызове функции учитывать тип данных параметров и их порядок. Т.е. при вызове функции с параметрами не следует
передавать в нее параметры других типов данных, иначе случится неявное преобразование типов данных (расширяющее/сужающее) с возможной потерей данных. Отсюда 2 правила:

    - ТИПЫ ДАННЫХ ПРИ ВЫЗОВЕ ФУНКЦИИ ДОЛЖНЫ СОВПАДАТЬ!
    - ПОРЯДОК ТИПОВ ДАННЫХ НЕ ДОЛЖЕН НАРУШАТЬСЯ!

Если первый идет char, а потом int, то только так необходимо вызывать функцию.
(!) void print_line(char Symbol, int Count);
    void print_line(int Count, char Symbol); разные функции, т.к. порядок их параметров разный, а след, вызывать эти функции нужно по-разному

Cтрока print_line(Symbol, Size); похожа на setlocale(LC_ALL, "rus"); Это говорит о том, что setlocale(LC_ALL, "rus"); это вызов функции с двумя параметрами! Первый па-
раметр указывает что нужно локализовать, а второй указывает каким языком это нужно сделать.

Создам ф.MyPow, возвращающую результат своей работы. Она будет возводить в степень целое цисло. Результатом функции будет число, возведенное в степень, след, необходимо
указать тип данных этого результата. Если целое число возведу в целую степень, то получу целый результат (int). Далее, чтобы функция смогла вернуть результат, нужна пе-
ременная, в которую результат поместится. int Result будет хранить промежуточный и конечный результат умножения. Далее в цикле for перемножатся п.Digit и Result. Чтобы
вернуть значение, полученное в результате работы функции, нужно использовать специальное ключевое слово return. В return нужно вписать что надо вернуть (что посчиталось
и вложилось в п.Result). П.Result будет возвращена именно в то место где вызвалась функция. Оператор return не только возвращает результат, но и прерывает работу функ-
ции, а след, все что будет написано после return, когда он сработает, выполнено не будет.

(!) Оператор return ДОЛЖЕН быть в той функции в которой возвращается значение. При указании чего-то кроме void при описании функции, необходимо вернуть указанный тип
данных и только его. Если указан int, то в return надо указать значение ТОЛЬКО типа int. Если функция возвращает void, то return в ней не нужен. Более того, если return
есть, то он должен обязательно выполниться. return-ов в функции может быть несколько, но сработает всегда только один (либо по порядку, либо в зависимости от условия).

Как вызвать функцию возвращающую результат?
Если прописать MyPow(5,3); то на экране ничего не будет, т.к. вывода на экран нет. Функция выполнится, и в нее будет возвращен результат ее работы, след, вызов функции
нужно поместить в cout. Чтобы сохранить результат работы функции нужно подходящее хранилище. Самым популярным хранилищем явл. переменная. Она должна быть с результатом
одного типа данных. Если функция возвращает int, то и хранилище для этого результата тоже должно быть типа данных int. */

int MyPow(int Digit, int Pow)                                                               // функция принимает 2 параметра и возвращает результат типа данных int
{
    int Result = 1;
    for (int i = 0; i < Pow; i++)
    {
        Result *= Digit;
    }
    return Result;                                                                          // оператор return возвращает результат работы функции (значение)
    cout << "Ура!" << endl;                                                                 // мы никогда эту фразу на экране не увидим, потому что она не сработает.
}

int main()
{
    setlocale(LC_ALL, "rus");
    Hello();                                                                                // вызов функции без параметров
    Stars(5);                                                                               // вызов функции с одним параметром

    int Count = 10;
    Stars(Count);                                                                           // вызов функции со значением переменной в качестве параметра

    cout << "Введите значение с клавиатуры: "; cin >> Count;
    Stars(Count);

    print_line('%', 11);                                                                    // вызов функции с двумя параметрами

    int Size = 0;
    char Symbol = '+';
    cout << "Введите символ: "; cin >> Symbol;
    cout << "Введите количество символов: "; cin >> Size;
    print_line(Symbol, Size);

    MyPow(5, 3);                                                                            // вот такой вызов возвращающей функции бессмыслен
    cout << "Число 5 в степени 3: " << MyPow(5, 3) << endl;
    int Result = MyPow(Count, Size);                                                        // инициализация п.Result результатом работы ф.MyPow();

    /* В тот момент когда компилятор дойдет до строки выше, он вызовет ф.MyPow(); перейдет в ее инициализацию, передаст в нее значения 5 и 3 (Digit будет равен 5, а Pow
    3), выполнится все что было указано в функции, а когда встретится return, вычисленный результат вернется туда где функция была вызвана. В итоге, результат работы
    функции будет помещен в п.Result и ее можно вывести на экран. */

    cout << "Результат: " << Result << endl;

    /* Ф.int Result = MyPow(5, 3); похожа на ГСЧ int A = rand(); Ее мы вызывали и результат помещали в переменную. Во время вызова ф.rand компилятор передавал ей управ-
    ление, выполнял все что у нее внутри, получал результат, помещал в return и передавал в нужную переменную.

    Если функция результат не возвращает, она все равно может содержать оператор return т.к. return еще и прерывает работу функции (стоп-кран). Напр. ф.print_line (по-
    лучает количество символов), в ней какого-то конкретного значения вернуть не получится, а лишь завершить работу функции и вернуться в main. Т.е. return можно ис-
    пользовать в функции как break в цикле. Если функция возвращает void, то в ней тоже может быть return. Он будет без каких-то значений, просто сам с ';'. Он сработа-
    ет как экстренный выход из функции если что-то пошло не так или выполнилось все что нужно. В void return можно писать по усмотрению, а в функции, возвращающей зна-
    чения return быть обязан. Посмотрим в отладчике как return возвращает нас обратно.

(!) функции, как и переменные, константы, массивы создаются и занимают место в ОЗУ!
(!) return в main есть, при компиляции студия его сама добавляет как return 0; Т.е. если я его не добавлю, то функция выполнится с возвратом нуля. А если напишу, напр.
    return 555; то функция выполнится с кодом 555 (я увижу 555 в строке перед закрытием программы). У ф.main можно написать void main, но компилятор сам изменит void на
    int т.к. необходимо возвращать данные о том, удачно ли отработала программа (студия много чего делает без моего согласия). Более того, у ф.main есть даже параметры. */
}