#include <iostream>
#include <locale.h>
using namespace std;
/* Функция это конструкция языка программирования, с помощью которой какой-либо фрагмент кода можно вынести за пределы функции main и использовать неоднократно в любом
месте моей программы. Функции создается имя, и по этому имени идет связь с функцией. Функции создаются для фрагментов кода повторяющихся в программе в разных местах
несколько раз, которые можно вынести за тело программы (за функцию main). Этот фрагмент кода получает собственное имя и далее может быть использован в необходимом месте
при указании его имени.

                                                            Назначения функций
1. Чтобы не писать одно и тоже несколько раз.
2. Собрать в единый механизм/конструкцию часть программы, выполняющую какое-то действие. А именно, если надо какую-то сложную конструкцию обособить и вынести за тело
программы (функции позволяют разбить всю программу на блоки/модули/механизмы).

В функцию можно пометить все механизмы, изученные ранее (if else, switch, циклы, массивы, одиночные переменные, константы...)
У функции есть 2 основных компонента, заголовок и тело. Заголовок определяет сигнатуру функции. Сигнатура функции это определенный набор характеристик, определяющий
функцию и отличающий ее от других функций. Функции, как и массивы, поддерживаются самим языком программирования и никаких библиотек для них подключать не требуется. За-
головок функции еще называется объявление функции, а тело - реализация функции.

                                                            Заголовок состоит из:
1. Имя функции (задается нами при объявлении функции)
2. Параметры (аргументы) функции - значения, которые нужно в функцию передать, чтобы она смогла на их основании выполнить какие-то действия. Это входные данные, необхо-
   димые функции для работы над кодом. В качестве параметров можно использовать много чего, но чаще всего переменные.
3. Возвращаемые значения - результат работы функции. Функция обязательно должна возвращать значение. Если у функции есть какой-то конечный результат работы, например,
функция вычисляет площадь прямоугольника, то ее результат будет площадь прямоугольника. Если результат у функции однозначный (одиночное, точное, осознанное, ощущаемое,
известное, осмысленное значение), то при объявлении (описании) функции необходимо указать тип данных этого значения, например int main(). Если же неизвестно или у функ-
ции нет одиночного однозначного значения, например, функция лишь что-то выводит на экран консоли, то она при этом никаких вычислений, никаких мат.операций и прочего не
выполняет, след, и осознанного результата у нее тоже нет. Но у нее должен быть указан тип возвращаемого значения (void) все равно.

Все функции создаются вне функции main. Создавать новую функцию внутри main нельзя, но можно созданную снаружи функцию использовать внутри main.

                                                            Функции можно создавать двумя способами:

I. Объявляем функцию и там же пишем ее содержимое (неразрывно заголовок и тело).
II. Объявляем функция прототипом и пишем реализацию после функции main (но об этом позже)

                                                            Объявление и реализация функции
Сперва пишем возвращаемое значение - результат работы функции. Функция для "Привет, Мир!" конечное значение (вычисленное число) иметь не будет. Она лишь выведет текст
на экран. Если у функции нет осознанного одиночного конкретного результата работы, ставится ключевое слово void, пишется имя функции и ставятся (). В () вносятся пара-
метры, которые функция должна принять для своей работы. Т.к. моя функция выводит лишь текст на экран, то ей никаких параметров и не надо (текст везде одинаковый, без
изменений), () будут пустыми. Затем, ставятся блоковые фиг.скобки, в которых находится тело функции. В заголовке указывается тип возвращаемого значения (void или конк-
ретный тип данных возврата), а далее имя и параметры, передаваемые в функцию для ее работы. */

void Hello()                                                                                // не принимает никаких параметров и не возвращает результат
{
    cout << "Hello world!" << endl;
}
/* В тех местах, где нужно использовать содержимое этой функции (вывести текст на экран), нужно лишь обратиться к функции Hello (вызвать функцию). Чтобы вызвать функцию
нужно написать ее имя и передать ей параметры, необходимые для ее работы. Но т.к. моей функции Hello никаких параметров для работы не требуется, то вызовится она тоже
просто. Там, где нужно вызвать функцию, я лишь напишу ее имя и укажу пустые скобки (). Скобки () обязательны, даже если нет параметров, т.к. именно скобки () обозначают
вызов функции. ';' в конце обязательна, т.к. вызов функции это законченная мысль. Эта функция без параметров.

Также функции бывают принимающие параметры и возвращающие результат. Создадим функцию, которая будет принимать один параметр, но не будет возвращать результат. Например
функция будет выводить на экран заданное количество звездочек. Функция примет количество звездочек в качестве параметра и выведет на экран заданное количество звездочек.
Т.к. количество звездочек для вывода будет задано, функция не будет ничего вычислять, а след, возвращать результат она не будет, будет void. А принимать она будет ко-
личество звездочек в качестве параметра, след, необходимо в круглых скобках указать параметр, его тип данных и имя. Для количества звездочек будет int. Функция содержит
переменную, которую нужно задать для выполнения цикла, но в самой функции cin нет, след, нужно задать значение переменной при вызове функции. Это называется принять 1
параметр (одну переменную). Принятие осуществляется заданием переменной в круглых скобках при вызове функции. */

void Stars(int Count)                                                                       // принимает 1 параметр и не возвращает результат
{
    for (int i = 0; i < Count; i++)
    {
        cout << "*";
    }
    cout << endl;
}
/* Как работают функции?
В момент вызова функции основная программа встает на паузу. Она останавливается и управление переходит в функцию (в то место где функция инициализировалась/лежит в ОЗУ)
и функция начинает работу. До тех пор пока она работает, main стоит на паузе. Как только все действия, указанные в теле функции выполнятся, компилятор вернется в место
вызова функции и продолжит дальнейшие действия по коду программы. Это ярко видно в отладчике (Step Into/Шаг с заходом). Это отладка с заходом в функции, которые написа-
ны для моей программы. Передам значение '5' и распишу механику:
При вызове функции компилятор переходит к открывающейся фиг.скобке, происходит внутреннее действие. Те параметры, указанные в заголовке функции (int Count) создадутся и
получат значения, переданные при вызове '5'. В момент вызова функции Stars будет создана переменная int Count, она получит значение '5' и будет использоваться в моей
функции.
(!) все, что создается внутри функции, доступно только внутри функции и пока функция работает.
Как только функция закончила работу, переменная Count будет уничтожена и больше к ней доступа не будет. А след, имена параметров функции могут быть точно такими же как
и названия других объектов кода. Они никак не будут связаны. Count в функции main и Count в функции Stars это абсолютно разные переменные, никак не связанные между со-
бой. Count в Stars живет только в функции Stars, а Count из main живет только в main. Когда я вызову функцию Stars и напишу в ней Count из main, то значение переменной
Count из main перейдет в Count из Stars и функция Stars будет с этим значением работать.

Т.о. передается не сама переменная в функцию, а лишь ее значение, след, в main передающая переменная может иметь любое имя, необязательно такое же как в функции Stars.
Также можно перед передачей значения в функцию, ввести это значение с клавиатуры. Пусть функция будет выводить на экран не заданный, а любой символ, след, она будет
принимать два параметра (количество символов и сам символ). Функция будет выводить на экран линию из символов и не будет ничего возвращать, ни площадь, ни рассчет з/п,
она просто будет выводить звездочки. */

void print_line(char Symbol, int Count)                                                     // функция принимает два параметра, но не возвращает результат
{
    if (Count <= 0)
    {
        cout << "Количество символов должно быть больше нуля!" << endl;
    }
    for (int i = 0; i < Count; i++)
    {
        cout << Symbol;
    }
    cout << endl;
}

/* Сигнатура функции это void print_line(char Symbol, int Count). В нее входят возвращаемое значение, имя функции и параметры (их количество и типы данных).
Переменная Count в функции print_line не имеет никакого отношения к переменной Count функции main или функции Stars. Это три разные переменные с одним именем, обладаю-
щие разной областью видимости. Когда используется функция с 2-я и более параметрами, нужно при вызове функции учитывать тип данных параметров и их порядок. Т.е. при вы-
зове функции с параметрами не следует передавать в нее параметры других типов данных, иначе произойдет неявное преобразование типов данных (расширяющее/сужающее) с воз-
можной потерей данных. Отсюда 2 правила:

    - ТИПЫ ДАННЫХ ПРИ ВЫЗОВЕ ФУНКЦИИ ДОЛЖНЫ СОВПАДАТЬ!
    - ПОРЯДОК ТИПОВ ДАННЫХ НЕ ДОЛЖЕН НАРУШАТЬСЯ!

Если первый идет char, а потом int, то только так необходимо вызывать функцию.
(!) void print_line(char Symbol, int Count);
    void print_line(int Count, char Symbol); разные функции, т.к. порядок их параметров разный, а след, вызывать эти функции нужно по-разному

Cтрока print_line(Symbol, Size); похожа на setlocale(LC_ALL, "rus"); Это говорит о том, что setlocale(LC_ALL, "rus"); это вызов функции с двумя параметрами! Первый па-
раметр указывает что нужно локализовать, а второй указывает каким языком это нужно сделать. */

int MyPow(int Digit, int Pow)                                                               // функция принимает 2 параметра и возвращает результат типа данных int
{
    int Result = 1;
    for (int i = 0; i < Pow; i++)
    {
        Result *= Digit;
    }
    return Result;                                                                          // оператор return возвращает результат работы функции (значение)
    cout << "Ура!" << endl;                                                                 // мы никогда эту фразу на экране не увидим, потому что она не сработает.
}

int main()
{
    setlocale(LC_ALL, "rus");
    Hello();                                                                                // вызов функции без параметров
    Stars(5);                                                                               // вызов функции с одним параметром

    int Count = 10;
    Stars(Count);                                                                           // вызов функции со значением переменной в качестве параметра

    cout << "Введите значение с клавиатуры: "; cin >> Count;
    Stars(Count);

    print_line('%', 11);                                                                    // вызов функции с двумя параметрами

    int Size = 0;
    char Symbol = '+';
    cout << "Введите символ: "; cin >> Symbol;
    cout << "Введите количество символов: "; cin >> Size;
    print_line(Symbol, Size);

    /* Создам функцию MyPow, возвращающую результат своей работы. Она будет возводить в степень целое цисло. Результатом функции будет число, возведенное в степень, след,
    необходимо указать тип данных этого результата. Если мы целое число возведем в целую степень, то получим целый результат (int). Далее, чтобы функция смогла вернуть ре-
    зультат, нужна переменная, в которую результат поместится. int Result будет хранить промежуточный и конечный результат умножения. Далее в цикле for перемножатся пере-
    менные Digit и Result. Чтобы вернуть значение, полученное в результате работы функции, нужно использовать специальное ключевое слово return. В return нужно вписать что
    надо вернуть (что посчиталось и вложилось в переменную Result). Переменная Result будет возвращена именно в то место где вызывалась функция. Оператор return не только
    возвращает результат, но и прерывает работу функции, а след, все что будет написано после return, когда он сработает, выполнено не будет.

    (!) Оператор return обязательно должен быть в той функции в которой возвращается значение. При указании чего-то кроме void при описании функции, необходимо вернуть ука-
    занный тип данных и только его. Если указан int, то в return нужно указать значение типа int (и никак иначе). Если функция возвращает void (не возвращает никакого ре-
    зультата), то return в ней не нужен. Более того, если return есть, то он обязательно должен выполниться. return-ов в функции может быть несколько, но всегда сработает
    только один (либо по порядку, либо в зависимости от условия).

    Как вызвать функцию возвращающую результат? Если просто прописать MyPow(5,3); то на экране ничего не будет, т.к. вывода на экран нет. Функция выполнится, и в нее будет
    возвращен результат ее работы, след, вызов функции нужно поместить в cout.
    Чтобы сохранить результат работы функции нужно подходящее хранилище. Самым популярным хранилищем явл. переменная. Она должна быть с результатом одного типа данных. Если
    функция возвращает int, то и хранилище для этого результата тоже должно быть типа данных int. */

    MyPow(5, 3);                                                                            // вот такой вызов возвращающей функции бессмыслен
    cout << "Число 5 в степени 3: " << MyPow(5, 3) << endl;
    int Result = MyPow(Count, Size);                                                        // инициализация переменной Result результатом работы функции MyPow();

    /* В тот момент когда компилятор дойдет до строки выше, он вызовет функцию MyPow(); перейдет в ее инициализацию, передаст в нее значения 5 и 3 (Digit будет равен 5,
    а Pow 3), выполнится все что было указано в функции, а когда встретится return, вычисленный результат вернется туда где функция была вызвана. В итоге, результат ра-
    боты функции будет помещен в переменную Result и мы можем вывести ее на экран и увидеть. */

    cout << "Результат: " << Result << endl;

    /* На что похожа функция int Result = MyPow(5, 3); На ГСЧ int A = rand(); Ее мы вызывали и результат поммещали в переменную. Мы уже работали с функциями, но не об-
    ращали на это внимание. Во время вызова функции rand компилятор передавал ей управление, выполнял все что есть у нее внутри, получал результат, который был записан
    в return и помещал в нужную переменную 'A'.

    Если функция результат не возвращает, она все равно может содержать оператор return т.к. return еще и прерывает работу функции (как стоп-кран). Например, функция
    print_line (получает количество символов), в ней какого-то конкретного значения вернуть не получится, а лишь завершить работу функции и вернуться в main. Т.о.
    return можно использовать в функции как break в цикле. Если функция возвращает void, то в ней тоже может быть return. Он будет без каких-то значений, просто сам с
    ';'. Он сработает как экстренный выход из функции если что-то пошло не так или выполнилось все что нужно. В void return можно писать по усмотрению, а в функции,
    возвращающей значения return быть обязан. Посмотрим в отладчике как return возвращает нас обратно.

   (!) функции, как и переменные, константы, массивы создаются и занимают место в ОЗУ!
   (!) return в main есть, при компиляции студия его сама добавляет как return 0; Т.е. если мы его не добавим сами, то функция выполнится с возвратом нуля. А если мы
       напишем, например, return 555; то функция выполнится с кодом 555 (мы увидим 555 в строке перед закрытием программы). У функции main можно написать void main, но
       компилятор сам изменит void на int т.к. необходимо возвращать данные о том, удачно ли отработала программа (студия много чего делает без моего согласия). Более
       того, у функции main есть даже параметры. */
}