#include <iostream>
#include <locale.h>
using namespace std;
/* Функция это конструкция языка программирования, с помощью которой фрагмент кода можно вынести за пределы ф.main и неоднократно использовать в любом месте моей прог-
раммы. Функции создается имя, и по этому имени идет связь с функцией. Функции создаются для фрагментов кода повторяющихся в программе в разных местах несколько раз, ко-
торые можно вынести за тело программы (за ф.main). Этот фрагмент кода получает собственное имя и далее может быть использован в нужном месте при указании его имени.

                                                                        Назначения функций
1. Чтобы не писать одно и тоже несколько раз.
2. Собрать в единый механизм/конструкцию часть программы, выполняющую какое-то действие. А именно, если надо какую-то сложную конструкцию обособить и вынести за тело
программы (функции позволяют разбить всю программу на блоки/модули/механизмы).

В функцию можно пометить все механизмы, изученные ранее (if else, switch, циклы, массивы, одиночные переменные, константы...)
У функции есть 2 основных компонента, заголовок и тело. Заголовок определяет сигнатуру функции. Сигнатура функции это определенный набор характеристик, определяющий
функцию и отличающий ее от других функций. Функции, как и массивы, поддерживаются самим языком программирования и никаких библиотек не требуют. Заголовок функции еще
называется объявление функции, а тело - реализация функции.

                                                                       Заголовок состоит из:
1. Имя функции (задается нами при объявлении функции)
2. Параметры (аргументы) функции - значения, которые нужно в функцию передать, чтобы она смогла на их основании выполнить какие-то действия. Это входные данные, необхо-
   димые функции для работы над кодом. В качестве параметров можно использовать много чего, но чаще всего переменные.
3. Возвращаемые значения - результат работы функции. Функция обязательно должна возвращать значение. Если у функции есть какой-то конечный результат работы, например,
функция вычисляет площадь прямоугольника, то результат ее будет площадь прямоугольника. Если результат у функции однозначный (одиночное, точное, осмысленное значение),
то при объявлении (описании) функции необходимо указать тип данных этого значения, напр. int main().
Если у функции нет одиночного однозначного значения или оно неизвестно, напр. функция лишь что-то выводит на экран консоли, то она при этом никаких вычислений, мат.опе-
раций и прочего не выполняет, след, и осознанного результата у нее тоже нет. Для нее должен быть указан тип возвращаемого значения void.

Все функции создаются вне функции main. Создавать новую функцию внутри main нельзя, но можно созданную снаружи функцию использовать внутри main.

                                                                Функции можно создавать двумя способами:

I. Объявление и реализация функции в одном месте (неразрывно заголовок и тело)
II. Объявление функции прототипом с реализацией после функции main

                                                                    Объявление и реализация функции:
Сперва пишем возвращаемое значение - результат работы функции. Функция для "Привет, Мир!" конечное значение (вычисленное число) иметь не будет. Она лишь выведет текст
на экран. Ставим ключевое слово void, пишим имя функции и ставим (). В () вносим параметры, которые функция должна принять для своей работы. Т.к. моя функция выводит
лишь текст на экран, то ей никаких параметров и не надо (текст везде одинаковый, без изменений), () будут пустыми. Затем, ставим блоковые фиг.скобки, в которых находит-
ся тело функции.

В тех местах, где нужно использовать содержимое этой функции (вывести текст на экран), нужно лишь обратиться к функции Hello (вызвать функцию). Чтобы вызвать функцию
нужно написать ее имя и передать ей параметры, необходимые для ее работы. Но т.к. моей функции Hello никаких параметров для работы не требуется, то вызовется она тоже
просто. Там, где нужно вызвать функцию, я лишь напишу ее имя и укажу пустые скобки (). Скобки () обязательны, даже если нет параметров, т.к. именно скобки () обозначают
вызов функции. ';' в конце обязательна, т.к. вызов функции это законченная мысль. Эта функция без параметров. */

void Hello()                                                                                // не принимает никаких параметров и не возвращает результат
{
    cout << "Hello world!" << endl;
}
/* Также функции бывают принимающие параметры и возвращающие результат. Пусть функция будет принимать 1 параметр, но не будет возвращать результат. Напр. функция будет
выводить на экран заданное количество звездочек. Функция примет количество звездочек в качестве параметра и выведет на экран заданное количество звездочек. Но т.к. ко-
личество звездочек для вывода будет задано, функция не будет ничего вычислять, а след, и возвращать результат она не будет, введу void. А принимать она будет количество
звездочек в качестве параметра, след, необходимо в круглых скобках указать параметр, его тип данных и имя. У количества звездочек будет int. Функция содержит переменную,
которую нужно задать для выполнения цикла, но в самой функции cin нет, след, нужно задать значение переменной при вызове функции. Это называется принять 1 параметр (од-
ну переменную). Принятие осуществляется заданием переменной в круглых скобках при вызове функции.

Как работают функции?
В момент вызова функции основная ф.main встает на паузу. Она стопорится и управление переходит в функцию (в то место где функция инициализировалась/лежит в ОЗУ) и функ-
ция начинает работу. До тех пор пока она работает, main стоит на паузе. Как только все действия, указанные в теле функции выполнятся, компилятор вернется в место вызова
функции и продолжит дальнейшие действия по коду программы. Это ярко видно в отладчике (Step Into/Шаг с заходом). Это отладка с заходом в функции, которые написаны для
моей программы. Передам значение '5' и распишу механику:
При вызове функции компилятор переходит к открывающейся фиг.скобке, происходит внутреннее действие: параметры, указанные в заголовке функции (int count) создадутся и
получат значения, переданные при вызове '5'.
(!) все, что создается внутри функции, доступно только внутри функции и пока функция работает.
Как только функция закончила работу, п.count исчезнет и больше к ней доступа не будет. А след, имена параметров функции могут быть точно такими же как и названия других
объектов кода. Они никак не будут связаны. count в ф.main и count в ф.Stars это абсолютно разные переменные, никак не связанные между собой. count в Stars живет только
в ф.Stars, а count из main живет только в main. Когда я вызову ф.Stars и напишу в ней count из main, то значение п.count из main перейдет в count из Stars и ф.Stars бу-
дет с этим значением работать. */

void Stars(int count)                                                                       // функцмя принимает 1 параметр и не возвращает результат
{
    for (int i = 0; i < count; i++)
    {
        cout << "*";
    }
    cout << endl;
}
/* Т.о. передается не сама переменная в функцию, а лишь ее значение, след, в main передающая переменная может иметь любое имя, необязательно такое же как в ф. Stars.
Также можно перед передачей значения в функцию, ввести это значение с клавиатуры. 
Пусть ф.Print_line будет выводить на экран любой символ, след, она будет принимать 2 параметра (количество символов и сам символ). Функция будет выводить на экран линию
из символов и не будет ничего возвращать, ни площадь, ни рассчет з/п, она просто будет выводить звездочки на экран. */

void Print_line(char symbol, int count)                                                     // функция принимает два параметра, но не возвращает результат
{
    if (count <= 0)
    {
        cout << "Количество символов должно быть больше нуля!" << endl;
    }
    for (int i = 0; i < count; i++)
    {
        cout << symbol;
    }
    cout << endl;
}
/* Сигнатура функции это void Print_line(char symbol, int count). В нее входят возвращаемое значение void, имя функции и параметры (их количество и типы данных).
П.count в ф.Print_line не имеет никакого отношения к п.count ф.main или ф.Stars. Это три разные переменные с одним именем, обладающие разной областью видимости. Когда
используется функция с 2-я и более параметрами, нужно при вызове функции учитывать тип данных параметров и их порядок. Т.е. при вызове функции с параметрами не следует
передавать в нее параметры других типов данных, иначе случится неявное (расширяющее/сужающее) преобразование типов данных с возможной потерей данных. Отсюда 2 правила:

    - ТИПЫ ДАННЫХ ПРИ ВЫЗОВЕ ФУНКЦИИ ДОЛЖНЫ СОВПАДАТЬ!
    - ПОРЯДОК ТИПОВ ДАННЫХ НЕ ДОЛЖЕН НАРУШАТЬСЯ!

Если первый идет char, а потом int, то только так необходимо вызывать функцию.
(!) void Print_line(char symbol, int count);
    void Print_line(int count, char symbol); разные функции, т.к. порядок их параметров разный, а след, вызывать эти функции нужно по-разному

Cтрока Print_line(symbol, size); похожа на setlocale(LC_ALL, "rus"); Это говорит о том, что setlocale(LC_ALL, "rus"); это вызов функции с двумя параметрами! 1-й пара-
метр указывает что нужно локализовать, а второй указывает каким языком это нужно сделать.

Пусть ф.MyPow, возвращает результат своей работы. Она будет возводить в степень целое цисло. Результатом функции будет число, возведенное в степень, след, нужно указать
тип данных этого результата. Если целое число возведу в целую степень, то получу целый результат (int). Далее, чтобы функция смогла вернуть результат, нужна переменная,
в которую результат поместится. int result будет хранить промежуточный и конечный результат умножения. Далее в цикле for перемножатся п.digit и result. Чтобы вернуть
значение, полученное в результате работы функции, надо использовать специальное ключевое слово return. В return нужно вписать что надо вернуть (значение, посчитанное в
п.result). П.result будет возвращена именно в то место где вызвалась функция. Оператор return не только возвращает результат, но и прерывает работу функции, а след, все
что написано после return, когда он сработает, выполнено не будет.

(!) Оператор return ДОЛЖЕН быть в той функции в которой возвращается значение. При указании чего-то кроме void при описании функции, надо вернуть указанный тип данных и
только его. Если указан int, то в return надо указать значение ТОЛЬКО int. Если функция возвращает void, то return в ней не нужен. Более того, если return есть, то он
должен обязательно выполниться. return-ов в функции может быть несколько, но сработает всегда только один (либо по порядку, либо в зависимости от условия).

Как вызвать функцию возвращающую результат?
Если прописать MyPow(5,3); то на экране ничего не будет, т.к. вывода на экран нет. Функция выполнится, и результат ее работы будет возвращен в место ее вызова, след,
вызов функции надо поместить в cout. Чтобы сохранить результат работы функции нужно подходящее хранилище. Самым популярным хранилищем явл. переменная. Она должна быть
одного типа данных с результатом работы функции. Если функция возвращает int, то и хранилище для этого результата тоже должно быть типа данных int. */

int MyPow(int digit, int pow)                                                               // функция принимает 2 параметра и возвращает результат типа данных int
{
    int result = 1;
    for (int i = 0; i < pow; i++)
    {
        result *= digit;
    }
    return result;                                                                          // оператор return возвращает результат работы функции (значение)
    cout << "Ура!" << endl;                                                                 // эта команда не выполнится, т.к. стоит после return
}

int main()
{
    setlocale(LC_ALL, "rus");
    Hello();                                                                                // вызов функции без параметров
    Stars(5);                                                                               // вызов функции с 1-м параметром

    int count = 10;
    Stars(count);                                                                           // вызов функции со значением переменной в качестве параметра

    cout << "Введите значение с клавиатуры: "; cin >> count;
    Stars(count);

    Print_line('%', 11);                                                                    // вызов функции с 2-мя параметрами

    int size = 0;
    char symbol = '+';
    cout << "Введите символ: "; cin >> symbol;
    cout << "Введите количество символов: "; cin >> size;
    Print_line(symbol, size);

    MyPow(5, 3);                                                                            // такой вызов возвращаемой функции бессмыслен
    cout << "Число 5 в степени 3: " << MyPow(5, 3) << endl;                                 // вывод на экран результата работы функции
    int result = MyPow(count, size);                                                        // сохранение результата работы функции

    /* В тот момент вызова ф.MyPow(); компилятор перейдет в ее инициализацию, передаст туда значения 5 и 3 (digit == 5, а pow == 3), выполнится все содержимое функции,
    а при встрече с return, вычисленный результат вернется в место вызова функции. Т.о., результат работы функции будет помещен в п.result и ее можно вывести на экран. */

    cout << "Результат: " << result << endl;

    /* Ф.MyPow(5, 3); похожа на ГСЧ rand(); Ее мы вызывали и результат помещали в переменную. Во время вызова ф.rand() компилятор передавал ей управление, выполнял все
    что у нее внутри, получал результат, помещал в return и передавал в нужную переменную.

    Если функция результат не возвращает, она все равно может содержать return т.к. return еще и прерывает работу функции (стоп-кран). Напр. ф.Print_line (получает ко-
    личество символов), в ней какого-то конкретного значения вернуть не получится, а лишь завершить работу функции и вернуться в main. Т.е. return можно использовать в
    функции как break в цикле. Если функция возвращает void, то в ней тоже может быть return. Он будет без каких-то значений, просто сам с ';'. Он сработает как экст-
    ренный выход из функции если что-то пошло не так или выполнилось все что нужно. В void return можно писать по усмотрению, а в функции, возвращающей значения return
    быть обязан. Посмотрим в отладчике как return возвращает нас обратно.

(!) функции, как и переменные, константы, массивы создаются и занимают место в ОЗУ!
(!) return в main есть, при компиляции студия его сама добавляет как return 0; Т.е. если я его не добавлю, то функция выполнится с возвратом нуля. А если напишу, напр.
    return 555; то функция выполнится с кодом 555 (я увижу 555 в строке перед закрытием программы). У ф.main можно написать void main, но компилятор сам изменит void на
    int т.к. необходимо возвращать данные о том, удачно ли отработала программа (студия много чего делает без моего согласия). Более того, у ф.main есть даже параметры. */
}