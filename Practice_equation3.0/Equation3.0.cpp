#include <iostream>
#include <cstdlib>
#include <windows.h>
using namespace std;

/* Напишу туже функцию, но с перегрузкой, которая будет решать и линейное, и кв.уравнение. Но реально, фактически у меня будет 2 функции: одна решил линейное, другая
кв.уравнение, но они будут объединены одним именем, поэтому их вызывать будет удобно.

Функция решения лин.уравнения
Т.к. это другая функция, поэтому она может возвращать не количество корней, а сам результат, т.к. в лин.уравнении 1 корень, след, сама функция может вернуть double и
она может получать параметры так как нужно мне, не как было в уравнении abc и в других вариантах, например как в математике kx + b. Более того, т.к. это линейное урав-
нение, то сразу можно, не создавая никаких переменных чтобы сохранять результат, вернуть результат, написав return. Получается что не нужна доп.переменная чтобы этот
результат сохранять. Можно добавить, как в предыдущем примере, вывод результата на экран, чтобы в функции проходило и вычисление, и вывод. */

inline double Equation(double k, double b)                                 // 
{
    cout << "x= " << -b / k << endl;                                       // реализация логики работы функции Equalization
    return -b / k;
}

// Перегрузка функции (две функции, но с одним именем и разными параметрами и по разному работающие). Возвращать она будет количество корней (int).
int Equation(double a, double b, double c)
{
    double x1 = 0.0, x2 = 0.0, D = 0.0;
    if (a == 0)                                                            // вызвать функцию Equation для лин.уравнения т.к. "b" и "с" у меня есть
    {
        Equation(b, c);
        return -1;                                                         // показывает что была попытка решить кв.уравнение, а передались значения линейного
    }
    D = (b * b) - 4 * a * c;
    if (D < 0)
    {
        cout << "D = " << D << endl;
        cout << "No actual roots!" << endl;
        return 0;
    }
    if (D == 0)
    {
        x1 = (-b) / (2 * a);
        cout << "x1=x2= " << x1 << endl;
        return 1;
    }
    x1 = ((-b) - sqrt(D)) / (2 * a);
    x2 = ((-b) + sqrt(D)) / (2 * a);
    cout << "x1= " << x1 << "\nx2= " << x2 << endl;
    return 2;
}
/* Перегрузка позволила настроить возврат тех чисел, в которых уже есть какой-то разумный смысл. Т.к. значение 1 будет ничем не занято ибо когда вычисляется лин.уравне-
ние вызывается совсем другая функция и будет совсем другое значение. А когда 2 одинаковых значения можно вернуть просто 2.

Функция double Equation для решения лин.уравнения имеет очень простую реализацию без сложных констрекций, которую можно встроить. double Equation встроится туда где я
я ее вызову, в перегрузке или в main. И тем самым функции double Equation вообще не будет т.к. она встроится на этапе компиляции и отдельно в памяти лежать не будет. Т.
о. При решении лин.уравнения не будет необходимости у функции main идти в память, искать и вызывать функцию, ждать окончание ее работы..., а будет произведено встраива-
ние. Это экономия времени и ресурсов.
Чем тут хороша перегрузка: название одно, а функции абсолютно разные, объединенные общим делом - они обе решают уравнение. По факту это вообще будет встроенный код,
функция inline double Equation встроится в int Equation */

int main()
{
    system("chcp");
    system("cls");
    int choise = 0;
    double a = 0.0, b = 0.0, c = 0.0;
    do
    {
        cout << R"(------------------------------------------------Программа для решения уравнений!-------------------------------------------------------------------
1 - Линейное уравнение (kx + b = 0)
2 - Квадратное уравнение (ax^2 + bx + c = 0)
0 - Выход из программы
)";
        do
        {
            cout << "Выберите тип уравнения: "; cin >> choise;
            if (choise < 0 || choise > 2)cout << "Неверно выбран тип уравнения! Введите еще раз!" << endl;
        } while (choise < 0 || choise > 2);
        if (choise == 0)break;
        switch (choise)
        {
        case 1:
            cout << "Введите коэффициент \"k\": "; cin >> b;
            cout << "Введите коэффициент \"b\": "; cin >> c;
            Equation(b, c);     // если выбрано решение лин.уравнения, main не будет останавливаться и искать ф.Equation в памяти, компилятор сюда встроит по inline код
            break;
        case 2:
            cout << "Введите коэффициент \"a\": "; cin >> a;
            cout << "Введите коэффициент \"b\": "; cin >> b;
            cout << "Введите коэффициент \"c\": "; cin >> c;
            Equation(a, b, c);  // очень удобный вызов
            break;
        }
        system("pause");
        system("cls");
    } while (choise != 0);
    cout << "Выход..." << endl;
    Sleep(1500);
}
/* Удобно получилось, передали "b" так "b", "с" так "с". Сами функции получились простая линейная и посерьезнее квадратная, возвращаемые значения дадут понять сколько
корней: 0, 1 или 2. А -1 будет означать что вызывалась линейная, которой быть тут не должно. Суть перегрузки в том, что если несколько функций обладают одним именем,
они по разному могут выполняться, принимать разные параметры и возвращать разные значения. Реализация внутри их тоже может быть разная. Перегрузка чаще всего и исполь-
зуется когда нужно разное содержимое функции для схожих задач, которые можно объединить одним именем.
(!) память для каждой перегрузки отводится отдельно. Если она не встраивается (не inline), то память будет отдельная. Это недостаток перегрузки. Т.к. перегрузка это
несколько разных функций, все они лежат в памяти.

Когда соержимое функций отличается координально есть смысл в перегрузке. Это огромный выигрыш, как в примере выше. Но в ситуации с малыми отличиями в функциях, например
только в типах данных, есть спец.механизм, позволяющий создать общее определение функции, применяемое для различных топов данных, а именно реализация будет одна, а типы
данных можно использовать разные. Механизм этот называется шаблон функций - третий способ как упростить написание функций (1-й - параметры по умолчанию, 2-й способ это
перегрузка). */