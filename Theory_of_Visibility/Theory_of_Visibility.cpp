#include <iostream>
#include <locale.h>
#include <stdlib.h>

using namespace std;
/* Внутри ф.main нет параметров. По факту они есть, но они не видны, т.к. студия сама их добавляет при компиляции. Их можно дописать если надо. В качестве 1-го парамет-
ра ф.main получает имя и путь к программе:

C:\Users\alexej.popov\OneDrive - Accenture\Documents\Visual Studio 2022\Projects\Visible\x64\Debug\Visible.exe
Остальные параметры передаются при вызове.

Например, команда ping (проверка доступности узла) без параметра не действует. Пишется ping и IP АДРЕС, который нужно проверить: ping 8.8.8.8 (это IP адрес DNS сервера
Google). Но ping это не просто команда, это исполняемый .exe файл (ping.exe), который хранится в папке System32. Ф.main команды ping.exe принимает в 1-й параметр IP ад-
рес, а во 2-й ключи. Ключ -t означает что это будет бесконечный пинг.
Моя программа тоже может принимать ключи. 1-й параметр который передается в main это путь к ее .exe файлу. Он там есть всегда, но студия его не пишет для простоты. Т.е.
main это такая же функция, как и создающиеся, но отличается лишь тем что она единственная и именно ее запуск означает начало работы программы. А когда main завершает
работу, завершает работу и вся программа.
                                                                   Прототип функции
Напишу функцию, определяющую max из 2-х чисел. Новые функции встают выше ф.main и захламляют ее глоб.пространство. Чтобы его не засорять и использовать для создания
глоб.п. и к. есть прототип функции. Это сигнатура функции без реализации. А реализация пишется отдельно после ф.main. Прототипы пишутся перед main т.к. чтобы использо-
вать функцию нужно объявить ее до использования в main. Пишется тип возвр.значения, возвращать она будет макс.значение Max, а принимать будет 2 числа int A и int B и
будет искать среди них max. Прототип оканчивается ';'.

    int Max(int A, int B); - прототип функции.

';' в прототипе обязательна, а в обычной функции ее быть не должно. Реализация функции пишется как обычная функция без ';'. Прототип сообщает компилятору что где-то в
программе есть реализация функции под именем Max, возвращающая int и принимающая 2 параметра типа int.
(!) в прототипе можно не писать имена параметров, но их количество и типы данных обязательно должны быть int Max(int, int); А в реализации функции обязательно должны
быть и типы данных и имена параметров.
                                                                Область видимости (о.в.)
Люб. фиг.скобки в коде представляют собой о.в. (б.к.), и все что происходит внутри фиг.скобок доступно только внутри фиг.скобок. Если создать объект внутри фиг.скобок,
то жить он будет ЛИШЬ внутри этих фиг.скобок. У каждого объекта ограничена о.в. и жизни своими фиг.скобками: if else, switch, циклы... Как только программа выходит за
границы фиг.скобок, этот объект пропадет и доступ к нему будет утерян. Ф.main содержит фиг.скобки, поэтому все что создается внутри ф.main доступно лишь внутри main.
След, есть 2 понятия: лок. и глоб.о.в. (лок. и глоб.объект). Лок.о.в. ограничена фиг.скобками, а глоб.о.в. это все что находится до и после фиг.скобок ф.main. Все соз-
даваемые функции (за редким исключением) находятся в глоб.о.в. и доступны для вызова внутри ф.main.

(!) глоб.объекты создаются ДО запуска ф.main на этапе запуска программы (компиляции), а далее запускается ф.main и создаются все лок.объекты ф.main.
(!) созданное в глоб.пространстве доступно на протяжении ВСЕЙ программы в люб.месте, начиная от создания объекта и до конца программы: глоб.п./к./массивы.
(!) глоб.п. НЕ НУЖНО передавать в функцию в качестве аргумента, она и так в ней будет доступна, т.к. доступна по всему коду программы.

   Зачем нужны глоб.п.?
1. Чтобы передать значение из одной функции в другую (в ф.Max поменял, а в main отразилось и наоборот)
2. Чтобы использовать всепроникающий счетчик (напр. для подсчета количества вызовов функций) */

int Max(int A, int B);                                    // определение максимума из двух чисел

int global;                                               // глоб.п. сама инициализируется нулем, а лок.п. мусором
const float PI = 3.14F;                                   // глоб.к. сама не инициализируется нулем, ее надо инициализировать
int ccount = 0;                                           // счетчик вызовов функции

int main(int argc, char* argv[])                          // argc - argument count; argv - argument value
{
    setlocale(LC_ALL, "rus");
    int digit = 0;
    cout << "Глобальная переменная: " << global << endl;
    cout << "Глобальная константа: " << PI << endl;
/* Недостаток глоб.п.: если где-то в коде изменится глоб.счетчик (копированный код с глоб.п. ccount = 555), то во всех след.функциях будет неверное значение количества
вызовов функции (не 4, а 559). Люб. изменение глоб.п. влияет на все последующие места ее использования. Глоб.п. требуют детальной внимательности. */
    //сcount = 555;
    Max(3, 5);
    cout << "Глобальная переменная: " << global << endl;
    //callcount;                                                    // лок.п. ф.Max доступна только в ф.Max
    Max(3, 5);
    Max(3, 5);
    Max(3, 5);
    Max(3, 5);
    cout << "Количество вызовов функции: " << ccount << endl;
    system("pause");
    system("cls");
/* Одинаковые имена можно использовать в разных б.к. т.к. они никак не пересекутся. В одной о.в. нельзя создать переменную с одинаковым именем даже иного типа данных.
В б.к. я могу создать еще п.digit, но перед этим проверю если п.digit из ф.main уже объявлена до б.к. и явл. внешней для него (таже логика как и для счетчика до цикла
while, и использование его внутри цикла). ЛЮБАЯ ПЕРЕМЕННАЯ СОЗДАННАЯ ДО О.В. ДОСТУПНА В НЕЙ!

Если внутри б.к. (лок.о.в.) создать еще digit, то она станет лок.п. б.к. 2-е digit быть не может. Лок.п. подменит собой и внешнюю, и глоб.п. В отладчике (Locals) можно
посмотреть области видимости где сначала видна одна п.digit, а потом их стало 2-е, но 2-я живет лишь внутри б.к. Теперь в б.к. 2-е п.digit. Это возможно т.к. они хра-
нятся в разных местах памяти, а РАБОТА СО ВСЕМИ ОБЪЕКТАМИ ВЕДЕТСЯ ПО ИХ МЕСТОПОЛОЖЕНИЮ В ПАМЯТИ, а не по их именам.
Внутри б.к. видимой явл. лишь лок.digit = 100. А к digit из main, доступ пропадет т.к. лок.digit подменит собой digit из main, но лишь на время работы б.к. Сразу как
б.к. завершится, лок.digit подменится обратно на digit из main и далее будет работать digit из main, а к лок.digit б.к. доступ пропадет. Тоже самое будет и с глоб.к. */
    {
        double G = 9.8;                                                                  // лок.п., доступная только в ЭТОМ б.к.
        cout << "Локальная переменная G блока кода: " << G << endl;
        cout << "Локальная переменная digit ф.main: " << digit << endl;                  // п.digit из main доступна в этом б.к.
        int digit = 100;                                                                 // подмена п.digit из main лок.п.digit ЭТОГО б.к.
        cout << "Локальная переменная digit этого блока кода: " << digit << endl;
        cout << "Глобальная константа: " << PI << endl;
        /* Создам внутри б.к. лок.п.PI. Она подменит собой глоб.к.PI. Тип данных не имеет значение (пусть double). Если ИМЯ совпало, то будет замена. */
        double PI = 3.14519;
        cout << "Локальная переменная PI блока кода: " << PI << endl;
        /* Если при замене глоб.объекта локальным в б.к. нужно дотянуться до глоб.объекта с таким же именем в этом б.к. есть операция расширения о.в. "::". */
        cout << "Глобальная константа: " << ::PI << endl;
        /* (!) дотянуться можно лишь до глоб.объектов, которые созданы ДО ф.main. Эта операция не работает для объектов созданных в ф.main. */
    }
    cout << "Локальная переменная digit ф.main: " << digit << endl;                      // автоматическая обратная подмена лок.п.digit на digit из main
    //cout << "Локальная переменная G блока кода " << G << endl;                         // потеря доступа к "G" т.к. она вышла за границы б.к.
    return 0;
}
/* Стат.лок.п. не пропадает при выходе за о.в. Если я создам стат.лок.п. внутри ф.Max, то по завершению работы ф.Max эта переменная продолжит жить и будет жить до конца
работы программы. Стат.лок.п. создается 1 раз при 1-м вызове функции. При повторном вызове функции заново не создается, а хранит значение оставшееся от предыдущего вы-
зова ф.Max (только ф.Max, т.к. это ЛОК.п. ф.Max). Стат.лок.п. будет доступна лишь внутри ф.Max, но будет жить с момента создания и до конца работы программы. Получать к
ней доступ можно только внутри ф.Max. Обратиться к стат.п. в ф.main или еще где-либо НЕЛЬЗЯ.
(!) чтобы получить доступ к значениям стат.п. вне функции ее создания, нужно значения этой переменной вернуть в качестве результата работы функции (в return). Но в моем
примере return занят, поэтому callcount я могу обрабатывать только внутри функции.
(!) можно стат.п. передавать в глоб.п. (ccount = callcount;), но при этом нужно следить, чтобы ничто это значение не перехватило. */

int Max(int A, int B)                                                // реализация функции (не нужно передавать глоб.п. в виде параметра в функцию)
{
    //digit = -100;
/* в ф.main есть п.digit, а в ф.Max она недоступна т.к. это лок.п. ф.main. А глоб.п. будет доступна. */
    global = 100;
/* Если где-то изменить значение глоб.п., то далее в ней будет новое значение. При вызове ф.Max, значение глоб.п. будет уже не 0, а 100 т.к. в функции будет выполнено
изменение глоб.п. Со строчки вызова ф.Max п.global будет иметь новое значение. Если глоб.п. где-то случайно изменить, это повлияет на результат работы всех функций, в
которых п.global используется. С другой стороны, глоб.объекты очень удобно использовать одновременно во всех функциях для обмена значениями или для контроля. */
    int callcount = 0;
/* Создав лок.п. внутри функции, она живет только внутри функции и лишь внутри выполненного вызова этой функции. Пусть в ф.Max будет счетчик callcount, который сосчита-
ет количество вызовов ф.Max. Он будет увеличиваться с каждым вызовом функции. Внутри ф.main эта переменная недоступна. Вызову ф.Max 4 раза и увижу, что ф.Max была выз-
вана 4 раза, а счетчик не изменился (как был 1, так и остался). Это так т.к. лок.п. ф.Max при каждом вызове функции создается снова (как только функция завершила работу
callcount пропадает и при каждом след.вызове функции создается вновь), увеличиваясь на 1. Т.о. каждый следующий вызов функции - "первый".
(!) лок.п. при очередном вызове функции создается заново и использовать ее в качестве счетчика вызовов функции невозможно. А глоб.п. возможно. Созданная с начала работы
программы, она будет работать всю программу и пропадет лишь когда программа закончит свою работу. Глоб.п. сама инициализируется нулем, а не мусором! Создав глоб.п. еди-
нажды, к ней можно обращаться когда надо. */
    callcount++;                                                      // лок.п. ф.Max (не справилась как глоб.счетчик)
    ccount++;                                                         // глоб.п. будет использоваться как счетчик
    
    static int callcount2 = 0;
    callcount2++;
    cout << "Количество вызовов функции по лок.переменной: " << callcount << endl;                         // лок.п. не справляется со счетчиком ибо исчезает по завершению работы функции
    cout << "Количество вызовов функции по глоб.переменной: " << ccount << endl;         // вывод глоб.счетчика на экран в функции
    cout << "Количество вызовов функции по стат.переменной: " << callcount2 << endl;
    if (A > B)return A;
    else
        if (A == B)
        {
            cout << "Значения равны!" << endl;
            return A;                                                                    // return-ов может быть несколько, но в разных условиях чтобы сработал всегда
        }                                                                                // лишь один
        else return B;
}