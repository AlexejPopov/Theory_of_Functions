#include <iostream>
#include <locale.h>
#include <stdlib.h>

using namespace std;
/* Внутри ф.main нет параметров. По факту они есть, но они не видны, т.к. студия сама их добавляет при компиляции. Их можно дописать если надо. В качестве первого пара-
метра ф.main получает имя и путь к программе:

C:\Users\alexej.popov\OneDrive - Accenture\Documents\Visual Studio 2022\Projects\Visible\x64\Debug\Visible.exe
Остальные параметры передаются при вызове.

Например, команда ping (проверка доступности узла) без параметра не действует. Пишется ping и IP АДРЕС, который нужно проверить: ping 8.8.8.8 (это IP адрес DNS сервера
Google). Но ping это не просто команда, это исполняемый .exe файл (ping.exe), который хранится в папке System32. Команда ping.exe, ее ф.main, принимает в 1-й параметр
IP адрес, а во 2-й ключи. Ключ -t означает что это будет бесконечный пинг.
Моя программа тоже может принимать ключи. 1-й параметр который передается в main это путь к ее .exe файлу. Он там есть всегда, но студия его не пишет для простоты. Т.е.
main это такая же функция, как и создающиеся, но отличается лишь тем что она одна единственная и именно ее запуск означает начало работы программы. А когда main завер-
шает работу, завершает работу и вся программа.

                                                                           Прототип функции
Напишу функцию, определяющую max из 2-х чисел. Новые функции встают выше ф.main и захламляют ее глоб.пространство. Чтобы его не засорять и использовать для создания
глоб.п. и к. есть прототип функции. Это сигнатура функции без ее реализации. А реализация пишется отдельно после ф.main. Прототипы пишутся перед main т.к. чтобы исполь-
зовать функцию нужно объявить ее до использования в main. Пишется тип возвр.значения int, возвращать она будет макс.значение Max, а принимать будет 2 числа int A и int
B и будет искать среди них max. Прототип оканчивается ';'.

    int Max(int A, int B); - прототип функции.

';' в прототипе обязательна, а в обычной функции ее быть не должно. Реализация функции пишется как обычная функция без ';'. Прототип сообщает компилятору что где-то в
программе есть реализация функции под именем Max, возвращающая int и принимающая 2 параметра типа int.
(!) в прототипе можно не писать имена параметров int Max(int, int); но их количество и типы данных обязательно нужно указывать. А в реализации функции обязательно долж-
ны быть типы данных и имена параметров.

                                                                        Область видимости (о.в.):
Люб. фиг.скобки в коде представляют собой о.в. (б.к.), и все что происходит внутри фиг.скобок доступно только внутри фиг.скобок. Если создать объект внутри фиг.скобок,
то жить он будет ЛИШЬ внутри этих фиг.скобок. У каждого объекта ограничена о.в. и жизни своими фиг.скобками: if else, switch, циклы... Как только программа выходит за
границы фиг.скобок, этот объект пропадет и доступ к нему будет утерян. Ф.main содержит фиг.скобки, поэтому все что создается внутри ф.main доступно лишь внутри main.
След, есть 2 понятия: лок. и глоб.объект (лок. и глаб.о.в.). Лок.о.в. ограничена фиг.скобками, а глоб.о.в. это все что находится до и после фиг.скобок ф.main. Все соз-
даваемые функции (за редким исключением) находятся в глоб.о.в. и доступны для вызова внутри ф.main.
(!) созданное в глоб.пространстве доступно на протяжении ВСЕЙ программы в люб. месте, начиная от создания объекта и до конца программы: глоб.п., массивы и к.

(!) в ф.main есть п.Digit, а в ф.Max она недоступна. Нельзя написать в ф.Max Digit = -100 т.к. это лок.п., живущая лишь в ф.main. Глоб.п. будет доступна. Она создастся
до вызова ф.main и объявится точно также как и лок.п. Если лок.п. не инициализировать при создании, в ней будет мусор, а в глоб.п. будет ноль. Глоб.к. по умолчанию ну-
лем не инициализируются, им надо вручную задать значения. Внутри ф.main можно вывести значение глоб.п./к. на экран.

(!) если где-либо изменить значение глоб.п., далее в ней будет новое значение. При вызове Max, значение глоб.п. будет уже не 0, а 100 т.к. в функции будет выполнено из-
менение глоб.п. Со строчки вызова ф.Max п.Global будет иметь новое значение. Если глоб.п. где-то случайно изменить, это повлияет на результат работы всех функций, в ко-
торых п.Global используется. С другой стороны, глоб.объекты очень удобно использовать одновременно во всех функциях для обмена значениями или для контроля.
(!) глоб.объекты создаются ДО запуска ф.main на этапе запуска программы (компиляции), а далее запускается main и создаются все лок.объекты ф.main.

   Зачем нужны глоб.переменные?
1. Чтобы передать значение из одной функции в другую (в Max поменял, в main отразилось и наоборот)
2. Чтобы использовать всепроникающий счетчик (например для подсчета вызовов функций)

Создав переменную внутри функции, она живет только внутри функции и лишь внутри выполненного вызова этой функции. Пусть в ф.Max будет счетчик, который сосчитает коли-
чество вызовов ф.Max - CallCount. Он будет увеличиваться с каждым вызовом функции. Внутри ф.main эта переменная недоступна. Вызову ф.Max 4 раза и увижу, что ф.Max была
вызвана 4 раза, а счетчик не изменился (как был 1, так и остался). Это так потому что лок.п. ф.Max при каждом вызове функции создается заново (сразу как функция завер-
шила работу CallCount пропадает и при каждом след. вызове функции создается заново) и увеличивается на 1. Т.о. каждый следующий вызов функции - "первый".
(!) лок.п. при очередном вызове функции создается заново и использовать ее в качестве счетчика вызовов функции невозможно. А глоб.п. нет. Созданная с начала работы
программы, она будет работать всю программу и пропадет лишь когда программа закончит свою работу. Глоб.п. сама инициализируется нулем, а не мусором! Создам счетчик глоб.
п.Count. Создав ее единажды, к ней можно обращаться когда надо.
(!) глоб.п. не нужно передавать в функцию в качестве аргумента, она и так в ней будет доступна, т.к. доступна по всему коду программы.

Недостаток глоб.п.: если где-то, скажем в ф.main, изменится глоб.счетчик (скопированный код с глоб.п.Count = 555), то счетчик во всех следующих функциях выдаст неверное
значение и выведет количество вызовов функции не 4, а 559. Люб. изменение глоб.п. влияет на все последующие места ее использования. Использование глоб.п. требует де-
тальной внимательности.

Прототип функции определения максимума из двух чисел: */
int Max(int A, int B);

int Global;                                                                 // глоб.п. инициализируется нулем
const float PI = 3.14F;
int Count = 0;                                                              // счетчик вызова функции

int main(int argc, char* argv[])                                            // argc - argument count; argv - argument value
{
    setlocale(LC_ALL, "rus");
    int Digit = 0;
    cout << "Глобальная переменная: " << Global << endl;
    cout << "Глобальная константа: " << PI << endl;
    Count = 555;                                                            // изменение глоб.п. влияет на все дальнейшие места ее использования
    Max(3, 5);
    cout << "Глобальная переменная: " << Global << endl;
    //CallCount;                                                            // лок.п. ф.Max доступна только в ф.Max
    Max(3, 5);
    Max(3, 5);
    Max(3, 5);
    Max(3, 5);
    cout << "Количество вызовов функции: " << Count << endl;

    /* Одинаковые имена можно использовать в разных б.к. т.к. они никак не пересекутся. В одной о.в. нельзя создать переменную с одинаковым именем даже иного типа данных.
   В б.к. я могу создать еще п.Digit, но перед этим проверю если п.Digit из ф.main уже объявлена до б.к. и явл. внешней для него (таже логика как и для счетчика до цикла,
   и использование его внутри цикла). ЛЮБАЯ ПЕРЕМЕННАЯ СОЗДАННАЯ ДО О.В. ДОСТУПНА В НЕЙ.

   Если внутри б.к. (лок.о.в.) создать еще Digit, то она станет лок.п. б.к. 2-е Digit быть не может. Лок.п. подменит собой и внешнюю, и глоб.п. В отладчике (Locals) можно
   посмотреть области видимости где сначала видна одна п.Digit, а потом их стало 2-е, но 2-я живет лишь внутри б.к. Теперь в б.к. 2-е п.Digit. Это возможно т.к. они хра-
   нятся в разных местах памяти, а РАБОТА СО ВСЕМИ ОБЪЕКТАМИ ВЕДЕТСЯ НЕ ПО ИХ ИМЕНАМ, А ПО ИХ МЕСТОПОЛОЖЕНИЮ В ПАМЯТИ.
   Внутри б.к., видимой явл. лишь лок.Digit = 100. А к Digit из main, доступ уже потерян т.к. лок.Digit подменила Digit из main, но лишь на время работы б.к. Сразу как б.к.
   закончится, лок.Digit подменится обратно на Digit из main и далее будет работать Digit из main. К лок.Digit б.к. доступ пропадет. Тоже самое произойдет и с глоб.к. Соз-
   дам внутри б.к. лок.п.PI, она подменит собой глоб.к.PI. Тип данных не имеет значение (пусть double). Если совпало имя, то произойдет замена.
   Если при замене в б.к. глоб.объекта локальным нужно дотянуться до глоб.объекта с таким же именем в этом б.к. есть операция расширения о.в. "::".
   (!) дотянуться можно лишь до глоб.объектов, которые созданы ДО ф.main. Эта операция не работает для объектов созданных в main */
    system("pause");
    system("cls");

    {
        cout << "Локальная переменная Digit функции main " << Digit << endl;            // п.Digit из main доступна в этом б.к.
        int Digit = 100;                                                                // подмена Digit из main лок.Digit ЭТОГО б.к.
        cout << "Локальная переменная Digit этого блока кода " << Digit << endl;
        double g = 9.8;                                                                 // лок.п., доступная только в ЭТОМ б.к.
        cout << "Локальная переменная g блока кода " << g << endl;
        cout << "Глобальная константа: " << PI << endl;
        double PI = 3.14519;
        cout << "Локальная переменная PI блока кода " << PI << endl;                    // подмена глоб.к.PI лок.PI ЭТОГО б.к.
        cout << "Глобальная константа: " << ::PI << endl;                               // ::PI - расширение о.в. до глобальной
    }
    cout << "Локальная переменная Digit функции main " << Digit << endl;                // автоматическая обратная подмена лок.п.Digit на Digit из main
    //cout << "Локальная переменная g блока кода " << g << endl;                        // потеря доступа к "g" т.к. она вышла за границы б.к.

    return 0;
}

/* Стат.лок.п. не уничтожается при выходе за о.в. Если я создам стат.лок.п. внутри ф.Max, то по завершению работы ф.Max эта переменная продолжит жить и будет жить до
конца всей работы программы. Стат.лок.п. создается один раз при первом вызове функции. При повторном вызове функции заново не создается, а хранит значение оставшееся от
предыдущего вызова ф.Max (только ф.Max, т.к. это ЛОК.п. ф.Max). Стат.лок.п. будет доступна лишь внутри ф.Max, но будет жить с момента создания и до конца работы всей
программы. Получать к ней доступ можно только внутри ф.Max. Обратиться к стат.п. в ф.main или еще где нельзя.
(!) чтобы получить доступ к значениям стат.п. вне функции ее создания, нужно значения этой переменной вернуть в качестве результата работы функции (в return). Но в моем
примере return занят, поэтому CallCount я могу обрабатывать только внутри функции.
(!) можно стат.п. передавать в глоб.п. (Count = CallCount;), но при этом нужно следить, чтобы ничто это значение не перехватило. */

int Max(int A, int B)                                                       // реализация функции (не нужно передавать глоб.п. в виде параметра в функцию)
{
    Count++;                                                                // глоб.п. будет использоваться как счетчик
    //Digit = -100;                                                         // лок.п. ф.main недоступна внутри ф.Max
    Global = 100;                                                           // глоб.п. доступна и внутри ф.Max
    int CallCount = 0;                                                      // лок.п. ф.Max (не справилась как глоб.счетчик)
    static int CallCount2 = 0;
    CallCount++;
    CallCount2++;
    cout << "Количество вызовов функции: " << CallCount << endl;                        // лок.п. не справляется со счетчиком ибо исчезает по завершению работы функции
    cout << "Количество вызовов функции по глоб.переменной: " << Count << endl;         // вывод глоб.счетчика на экран в функции
    cout << "Количество вызовов функции по стат.переменной: " << CallCount2 << endl;
    if (A > B)return A;
    else
        if (A == B)
        {
            cout << "Значения равны!" << endl;
            return A;                                                                   // return-ов может быть несколько, но сработает всегда только один  
        }
        else return B;
}