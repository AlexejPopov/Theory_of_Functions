#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;
/* Особенности передачи ДМ в функцию. ДМ это массив одномерных массивов. Для работы с ДМ создам 2 константы.
В первых кв.скобках указывается количество строк (i), а во-вторых, количество столбцов или элементов в строке (j). */

const int row = 10;
const int col = 6;

/* Зайду в отладчик: в Locals значения ДМ лежат последовательно, а если я открою его, то увижу, что это набор одномерных массивов (10 массивов по 6 элементов в каждом),
а отсюда выходит след.особенность передачи ДМ в функцию: указывается его ИМЯ и количество элементов в СТРОКАХ и СТОЛБЦАХ.
(!) при желании упростить, можно в кв.скобках указать минимум одно значение - количество элементов в строках (j) чтобы понимать длину каждого одномерного массива.

Никакой универсальности тут нет, т.к. при вызове моей функции для другого массива нужно менять значения ВРУЧНУЮ. Это не самый правильный способ работы с ДМ в функциях.
Правильный способ изучится позже.
При работе в функции с одномерным масивом можно было указать его размер в параметрах функции, но функцией этот размер будет проигнорен. Также у ДМ будет проигнорен раз-
мер количества строк в параметрах функции, а вот количество столбцов должно быть, т.к. функция должна понимать длину каждого одномерного массива в составе ДМ, чтобы
компилятор знал как разбить память т.к. в памяти ДМ лежит непрерывно, строчка за строчкой, поэтому и нужно знать сколько элементов лежит в каждой
строке чтобы разбить весь массив на отдельные строчки для работы в функции. К сожалению нельзя вписать переменную в ДМ, только константу. Единственное что тут можно
сделать: раз я обязан задавать размеры массива константами, то сделаем их глобальными (специально для задания размера ДМ). И тогда нет надобности отдельно передавать
размеры в функцию, т.к. они указаны глобально. И если я их в параметрах не напишу, функция их увидит напрямую (теория по областям видимости). Можно и row написать в па-
раметры, но оно оттуда браться не будет, и проигнорируется, но его можно там указать. А след, можно константу row создать обычной и строки передавать в качестве аргу-
мента при вызове функции.
Создам функцию, которая будет вычислять сумму всех элементов ДМ. Во вложенных циклах будет подсчитана сумма. */
int SummaAllElements(int Array[][col]/*, int row, int col*/)
{
    int summa = 0;
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col; j++)
        {
            summa += Array[i][j];
        }
    }
    return summa;
}

int main()
{
    system("chcp 1251");
    system("cls");
    srand(time(NULL));
    //const int row = 10;
    //const int col = 6;
    int Mass[row][col]{};
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col; j++)
        {
            Mass[i][j] = rand() % (100 - (-99)) - 99;
            cout << "Mass[" << i << "][" << j << "]=";
            if (Mass[i][j] >= 0)cout << " ";
            if (Mass[i][j] > -10 && Mass[i][j] < 10)cout << " ";
            cout << Mass[i][j] << "; | ";
        }
        cout << endl;
    }
    int summa = SummaAllElements(Mass);                                             // размеры будут взяты из глобальных констант
    cout << "Сумма всех элементов ДМ равна: " << summa << endl;
    /* Т.о. так работать с ДМ я не будем, т.к. в них жестко указывается размер константы в параметрах, след, этот способ хорош лишь с одномерными массивами. */
}