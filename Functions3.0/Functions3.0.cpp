#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;

const int row = 10;
const int col = 6;

/* Особенности передачи ДМ в функцию. Для работы с ДМ создам 2 константы.
(!) в первых квадратных скобках указывается количество строк, а во вторых указывается количество элементов в строке т.к. ДМ это массив одномерных массивов (10 массивов
по 6 элементов в каждом).
Зайдем в отладчик: в странице Locals значения двумерного массива лежат последовательно, а если я его открою, то увижу, что это набор одномерных массивов (10 мас-
сивов по 6 элементов в каждом), а отсюда выходит след.особенность передачи ДМ в функцию: при передаче ДМ в функцию также указывается его имя и количество элементов
в строках и столбцах, но внутри квадр.скобок необходимо указать как минимум одно значение - количество элементов в строках.

Создам функцию, которая будет вычислять сумму всех элементов ДМ и во вложенных циклах посчитаю сумму.
(!) при передаче ДМ в функцию необходимо указать количество элементов в строке (во вторых квадр.скобках необходимо указать значение). Никакой универсальности тут нет,
т.к. при вызове этой функции для другого массива нужно менять значение вручную. Это не самый правильный способ работы с ДМ в функциях. Правильный способ изучится позже.
При работе с одномерным масивом в функции можно было бы указать его размер в параметрах функции, но функцией этот размер будет проигнорирован. Точно также будет проиг-
норирован размер количества строк в параметрах функции у ДМ, а вот количество столбцов обязано быть, т.к. функция должна понимать длину каждого одномерного массива в
составе ДМ, чтобы функция знала как разбить всю память т.к. в памяти ДМ лежит непрерывно, строчка за строчкой, поэтому и нужно знать сколько элементов лежит в каждой
строке чтобы разбить весь массив на отдельные строчки для работы в функции. К сожалению нельзя вписать переменную в ДМ, только константу. Единственное что тут можно
сделать: раз я обязан задавать размеры массива константами, то сделаем их глобальными (специально для задания размера ДМ). И тогда нет надобности отдельно передавать
размеры в функцию, т.к. они указаны глобально. И если я их в параметрах не напишу, функция их увидит напрямую (теория по областям видимости). Можно и row написать в па-
раметры, но оно оттуда браться не будет, и проигнорируется, но его можно там указать. А след, можно константу row создать обычной и строки передавать в качестве аргу-
мента при вызове функции. */
int SummaAllElements(int Array[][col]/*, int row, int col*/)
{
    int summa = 0;
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col; j++)
        {
            summa += Array[i][j];
        }
    }
    return summa;
}

int main()
{
    system("chcp 1251");
    system("cls");
    srand(time(NULL));
    //const int row = 10;
    //const int col = 6;
    int Mass[row][col]{};
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < col; j++)
        {
            Mass[i][j] = rand() % (100 - (-99)) - 99;
            cout << "Mass[" << i << "][" << j << "]=";
            if (Mass[i][j] >= 0)cout << " ";
            if (Mass[i][j] > -10 && Mass[i][j] < 10)cout << " ";
            cout << Mass[i][j] << "; | ";
        }
        cout << endl;
    }
    int summa = SummaAllElements(Mass);                                             // размеры будут взяты из глобальных констант
    cout << "Сумма всех элементов ДМ равна: " << summa << endl;
    /* Т.о. так работать с ДМ я не будем, т.к. в них жестко указывается размер константы в параметрах, след, этот способ хорош лишь с одномерными массивами. */
}