#include <iostream>
#include <locale.h>
using namespace std;
/* Когда определяется функция, пишется ее заголовок, указываются ее параметры, которые называются также формальные параметры, т.е. те параметры, которые будут созданы
в момент вызова функции и получат в этот момент значения. Но память под эти параметры выделяется намного раньше. Соответственно поэтому мы можем в эти параметры помес-
тить значения по умолчанию. Параметры по умолчанию означают, что если при вызове функции мы не передадим значения этим параметрам, то они получат значения, указанные по
умолчанию.
Добавим в код усложнение в виде статич.переменной. Чтобы получить значение стат.переменной внутри функции main, а не только внутри функции, в которой она была создана
нужно возвращать в качестве аргумента, и если есть свободный return, то можно создать статический сетчик и подсчитывать количество вызовов созданной функции либо коли-
чество каких-то действий и возвращать значение этой стат.переменной в качестве результата работы функции. Стат.переменная создается в одной функции и до конца программы
к ней есть доступ из всех функций, но изменить ее можно только в функции где она была создана. Удобно когда механизм подсчета в самой функции живет.
Создам функцию вывода символов на экран в виде таблицы (';' указывает что у меня прототип функции). Возвращать она будет количество своих вызовов.

Параметры по умолчанию указываются в самом начале. Если у нас прототип, то они указываются только в прототипе. Если нет прототипа, то они указываются сразу в реализации
(!) значения параметров функции по умолчанию задаются начиная с последнего. Т.е. если я хочу задать значение переменной rows, я сперва должен задать значение для пере-
менной columns, а потом уже для rows (или поменять их местами, но это не всегда удобно). Если я хочу задать символ по умолчанию, то мне сперва нужно задать все что пос-
ле него.
Это все нужно для того, чтобы очередной раз вызывать функцию и не указывать ей все параметры (указание параметров тоже идет с конца). Я могу вызвать функцию, передав ей
лишь 2 параметра [2]. Указывая 2 параметра, будут заполнены первые два параметра, а последний получит значение по умолчанию. Только так. Мы не можем дать значение 1-му
и 3-му значению, а второму придать значение по умолчанию, скажем, при помощи запятых с пробелом или еще как-то. Так нельзя. Это так т.к. параметры функции в памяти рас-
полагаются непрерывно, один за другим. Задавать значения мы должны с конца и не указывать их тоже с последнего. Т.о. symbol я передам (*), rows я передам (3), а коли-
чество столбцов будет взято из параметров по умолчанию (10). Итого будет 3 строки по 10 звездочек.
Далее я могу вызвать функцию с одним параметром [3]. Я передам только символ, а строки и столбцы возьму по умолчанию, получу 1 линию из 10-ти звездочек. А далее вызову
функцию вообще без указания параметров [4]. На экране я увижу 1 строку из 10 процентов. При этом не важно как вызывается функция, т.е я могу при вызове задать параметр
не переменной, а символом [5]. Он попадет в начало. Т.е. если указывается один параметр при вызове функции, то это значение получит первый параметр из перечисленных на-
ми. Если у первого параметра не будет значения по умолчанию ('%' убран из умолчания), то тогда вызов функции без параметров [4] будет невозможным поскольку обязательно
один параметр должен иметь значение, иначе будет ошибка "слишком мало аргументов в вызове функции. Верну '%' в параметры по умолчанию. Можно указывать не все параметры
по умолчанию, а лишь те, которые нужны, но обязательно начиная с последнего. Передам '%' [5] и увижу это сработает. Или два параметра передам [6] и увижу 2 строки из 10
долларов.
А далее при последующих вызовах функции [7] и [8], вызовы не сработают, т.к. количество вызовов функции перешло 7 раз. [7] и [8] вызов функции не сработает из-за приня-
того условия if (call < 7).
(!) если есть прототип функции, то в реализации значения параметров по умолчанию не указываются, а указываются только в прототипе, а имена параметров можно не указывать
int Symbols(char = '%', int = 1, int = 10);
Далее мы научимся убирать реализацию функции аж в отдельную библиотеку. */

int Symbols(char symbol = '%', int rows = 1, int columns = 10);                 // использование "отвертки" очень удобно для создания блока реализции функции

int main()
{
	setlocale(LC_ALL, "rus");
	int rows = 3;
	int columns = 7;
	char symbol = '*';
	int count = 0;																// количество вызовов функции
	count = Symbols(symbol, rows, columns);										// [1] вызов функции с указанием значений всех параметров
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols(symbol, rows);												// [2] вызов функции со значением последнего параметра, взятого по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols(symbol);													// [3] вызов функции со значениями всех параметров кроме первого, взятых по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols();															// [4] вызов функции со значениями всех параметров, взятых по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols('&');														// [5] вызов функции со значениями всех параметров кроме первого, взятых по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols('$', 2);													// [6] вызов функции со значением последнего параметра, взятого по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;

	count = Symbols();															// [7]
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols();															// [8]
	cout << "Количество вызовов функции: " << count << "\n" << endl;

}

int Symbols(char symbol, int rows, int columns)
{
	static int call = 0;														// стат.переменная, считающая количество вызовов функции
	call++;																		// увеличение счетчика при каждом вызовове функции
	if (call < 7)
	{
		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < columns; j++)
			{
				cout << symbol;
			}
			cout << endl;
		}
	}
	else cout << "Превышено количество вызовов функции!" << endl;
	return call;
}