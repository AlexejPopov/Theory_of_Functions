#include <iostream>
#include <locale.h>
using namespace std; /* Параметры по умолчанию нужны чтобы очередной раз, вызвав функцию, не вводить ей все параметры снова.
Создается функция, пишется ее заголовок, указываются параметры, которые еще называются формальные параметры (параметры, которые будут созданы в момент вызова функции и
получат в этот момент значения. Но память под эти параметры выделяется намного раньше. След, в эти параметры можно поместить значения по умолчанию. Параметры по умолча-
нию означают, что если при вызове функции этим параметрам не передаются значения, то они получат значения, указанные по умолчанию.

Значения параметров по умолчанию вводятся в самом начале и с последнего. Т.е. чтобы задать значение п.rows, надо сперва задать значение для п.columns, а потом уже для
п.rows (или поменять их местами, но это не всегда удобно). Если нужен символ по умолчанию, то сперва надо задать все что после него (ввод параметров тоже идет с конца).

Добавлю в код усложнение в виде стат.п. Чтобы получить значение стат.п. внутри ф.main, а не только внутри ее родной функции надо вернуть ее в качестве аргумента. И если
есть свободный return, то можно создать стат.сетчик и подсчитать количество вызовов созданной функции (или количество каких-то действий и возвращать значение стат.п. в
качестве результата работы функции). Стат.п. создается в одной функции и до конца программы к ней есть доступ из всех функций, но изменить ее можно лишь в функции соз-
дания. Удобно когда механизм подсчета живет в самой функции. Пусть функция выводит символы на экран в виде таблицы. Возвращать она будет количество своих вызовов.

* Вызову функцию, передав ей лишь 2 параметра [2]. Заполнены будут 1-ые 2 параметра, а последний получит значение по умолчанию. Только так. Нельзя дать значение 1-му
и 3-му значению, а 2-му придать значение по умолчанию, напр, при помощи запятых с пробелом, т.к. параметры функции в памяти располагаются непрерывно, один за другим.
ЗАДАВАТЬ значения надо с конца и НЕ УКАЗЫВАТЬ их тоже с последнего. Т.о. в symbol введу (*), в rows (3), а количество столбцов будет взято из параметров по умолчанию
(10). Итого будет 3 строки по 10 звездочек.

* Далее вызову функцию с 1-м параметром [3]. Введу лишь символ, а строки и столбцы возьму по умолчанию, получу 1 линию из 10-ти звездочек.

* Далее вызову функцию вообще без указания параметров [4]. На экране будет 1 строка из 10 процентов. При этом не важно как вызывается функция, т.е. при вызове можно за-
дать параметр не переменной, а символом [5]. Он попадет в начало (если вводится 1 параметр при вызове функции, то это значение получит 1-ый параметр из перечисленных
мною. Если у 1-го параметра не будет значения по умолчанию ('%' убран из умолчания), то тогда вызов функции без параметров [4] будет невозможным т.к. 1 параметр обяза-
тельно должен иметь значение, иначе будет ошибка "слишком мало аргументов в вызове функции". Верну '%' в параметры по умолчанию.
Можно указывать не все параметры по умолчанию, а лишь те, которые нужны, но обязательно начиная с последнего. Передам '%' [5] и увижу что это сработает. Или 2 параметра
передам [6] и увижу 2 строки из 10 долларов.

* А далее при последующих вызовах функции [7] и [8], вызовы не сработают, т.к. количество вызовов функции перешло 7 раз. [7] и [8] вызов функции не сработает из-за при-
нятого условия if (call < 7).

(!) если есть прототип функции, то в реализации значения параметров по умолчанию не указываются, а указываются только в прототипе, а имена параметров можно не указывать
int Symbols(char = '%', int = 1, int = 10);
Далее мы научимся убирать реализацию функции аж в отдельную библиотеку. */

int Symbols(char symbol = '%', int rows = 1, int columns = 10);                 // использование "отвертки" очень удобно для создания блока реализции функции

int main()
{
	setlocale(LC_ALL, "rus");
	int rows = 3;
	int columns = 7;
	char symbol = '*';
	int count = 0;																// количество вызовов функции
	count = Symbols(symbol, rows, columns);										// [1] вызов функции с указанием значений всех параметров
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	cout << Symbols(symbol, rows, columns);										// сперва выполняется действие в теле функции и выводится на экран, а потом cout
	cout << endl;

	count = Symbols(symbol, rows);												// [2] вызов функции со значением последнего параметра, взятого по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols(symbol);													// [3] вызов функции со значениями rows и columns взятых по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols();															// [4] вызов функции со значениями всех параметров, взятых по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols('&');														// [5] вызов функции со значениями всех параметров кроме первого, взятых по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols('$', 2);													// [6] вызов функции со значением последнего параметра, взятого по умолчанию
	cout << "Количество вызовов функции: " << count << "\n" << endl;

	count = Symbols();															// [7]
	cout << "Количество вызовов функции: " << count << "\n" << endl;
	count = Symbols();															// [8]
	cout << "Количество вызовов функции: " << count << "\n" << endl;
}

int Symbols(char symbol, int rows, int columns)
{
	static int call = 0;															// стат.п., считающая количество вызовов функции
	call++;																			// увеличение счетчика при каждом вызовове функции
	if (call < 7)
	{
		for (int i = 0; i < rows; i++)
		{
			for (int j = 0; j < columns; j++)
			{
				cout << symbol;
			}
			cout << endl;
		}
	}
	else cout << "Превышено количество вызовов функции!" << endl;
	return call;
}